\Chapter{REVUE DE LITTÉRATURE}\label{sec:RevLitt}

Le \emph{model-checking} rassemble des techniques permettant de vérifier
et valider des systèmes. Ces techniques se basent sur l'exploration
exhaustive d'un modèle du système, c'est à dire d'une représentation
abstraite et simplifiée de celui-ci. Historiquement, le model-checking a
tout d'abord été utilisé pour la vérification de composants
électroniques. Les techniques ont ensuite été adaptées afin de permettre
la validation de programmes. Nous allons par la suite nous intéresser à
ces techniques uniquement.

De nombreux algorithmes de model-checking ont été développés en fonction
des propriétés à vérifier sur le système, du formalisme dans lequel est
exprimé le modèle et de la complexité de celui-ci.

Dans cette partie, nous présentons les principales techniques de
model-checking logiciel et nous identifions leurs avantages et
inconvénients respectifs.

Pour chacune de ces techniques, nous identifions les outils les plus performant
les implémentant à l'heure actuelle. Nous restreignons cependant cette étude au
cadre qui nous intéressera pour la suite de ce rapport. Nous ne considèrerons
donc que des outils capables de vérifier des programmes concurrents en C,
suivant le modèle de d'exécution définis par la norme POSIX (pthread).

\textbf{Structure :} Dans la section~\ref{sec:model-checking-logiciel}, nous
définissons le model-checking logiciel et une représentation formelle des modèle
qui lui sont associés. Dans la section~\ref{sec:specification}, nous présentons
les types de propriétés des programmes vérifiables grâce au model-checking et
les formalismes utilisés pour les exprimer et les représenter formellement.
Enfin, dans la section~\ref{sec:techniques-et-outils-de-model-checking}, nous
présentons différentes techniques utilisées pour le model-checking de programmes
multi-thread ainsi que les outils qui les implémentent.

\section{Model-checking logiciel}\label{sec:model-checking-logiciel}

Le model-checking permet de vérifier qu'un système respecte une
spécification donnée. Le principe sous-jacent est de mener une recherche
exhaustive à travers une modélisation du système plutôt que de
construire une preuve formelle de validité. Alors qu'une telle preuve
peut demander une certaine part d'intuition, le model-checking permet
une approche plus systématique, qui peut être plus facilement
automatisée.

\subsection{Modèle}


Le point caractéristique du model-checking est l'utilisation de
\emph{modèles} des systèmes à vérifier. Un modèle est une représentation
abstraite du système. Au lieu de vérifier un système directement, les techniques
de modèle checking s'appliquent sur le modèle du système. On considère un
système comme correct lorsque son modèle ne contient pas d'erreurs.

L'origine des modèle est liée au domaine d'application initial du
model-checking : la vérification du design de composants électroniques. Il
était nécessaire de représenter ces derniers de manière abstraite afin de les
vérifier, ce qui a donné naissance à la notion de modèles.

L'utilisation d'un modèle permet de simplifier les tâches de vérification : un
modèle bien conçu capture le fonctionnement du système en retirant les détails
n'ayant pas d'impact sur les propriétés à vérifier. Cette version simplifiée du
système permet ainsi de réaliser des tâches de vérification complexes, qui ne
pourraient aboutir autrement. Cependant, le modèle doit être suffisamment fidèle
pour préserver les propriétés à vérifier. Un modèle trop simple pourrait
provoquer l'apparition de faux positifs ou pire, ne pas contenir une erreur
pourtant bien présente dans le système.

La phase de modélisation est donc une phase délicate et propice aux erreurs. Il
est nécessaire de bâtir un équilibre entre l'abstraction du système et le
respect de son fonctionnement, cet équilibre dépendant des propriétés que l'on
souhaite vérifier. La modélisation demande donc à la fois une bonne connaissance
du système et des outils de model-checking utilisés. Les tendances actuelles
visent à réduire l'intervention humaine dans la phase de modélisation en
automatisant celle-ci.

\subsection{Système de transitions et trace d'exécution}

Un modèle prends souvent la forme d'un système de transitions.

\paragraph{Système de transitions}
Formellement, un système de transitions est une paire \((S, \rightarrow)\),
avec :

\begin{itemize}
\item
  \(S\) l'ensemble des états du système ;
\item
  \(\rightarrow \subset S \times S\) la relation de transitions du
  système ;
\end{itemize}

Intuitivement, les états d'un système de transitions représentent un
statut possible du système, tandis que les transitions représentent les
actions qui peuvent le faire évoluer.

\paragraph{Trace d'exécution}
Une trace d'exécution est un chemin dans le système de transition
représentant le modèle, possiblement infini, dont le premier état est
l'état initial du modèle. Une trace d'exécution est donc formé d'une
suite \(s_0, s_1, .. \in S\) d'états, avec \(s_0\) un état initial, et
d'une suite \(t_0, t_1, ... \in \rightarrow\) de transitions telles que
\(\forall i, t_i = (s_i, s_{i+1})\).

Le model-checking consiste à examiner l'ensemble des traces
d'exécution du modèle afin de vérifier si elles respectent la spécification.

\subsection{Model-checking logiciel}

Lorsque le système à vérifier est un programme, il est possible de
générer le modèle automatiquement à partir du code source du programme.
On parle dans ce cas de \emph{software model checking}, ou
model-checking logiciel. Générer le modèle à partir du code source (ou
même considérer directement que le modèle \emph{est} le code source)
permet de gagner sur deux plans :

Le model-checking logiciel, ou \emph{software model checking} est un cas
particulier de model-checking. Le système a vérifier est un programme, et le
modèle va être extrait automatiquement à partir de son code source.
On automatise ainsi la conception du modèle, ce qui présente les avantages
suivants :

\begin{itemize}
\item
  on réduit le risque d'une erreur lors de la modélisation du système,
  en supprimant l'intervention humaine ;
\item
  on automatise d'avantage le procédé de vérification, ce qui le rend
  plus facilement utilisable en pratique.
\end{itemize}

Cependant, le code doit encore être compilé afin d'obtenir le système,
ce qui constitue une encore une certaine distance entre le modèle et le
système. Afin de réduire cette distance, certains
model-checkers logiciels se basent sur des représentations intermédiaires
plus proches de l'assembleur, comme la représentation intermédiaire de
LLVM\footnote{L'utilisation de cette représentation est aussi expliquée
  par des raisons de compatibilité. De nombreux langages dont C, C++ ou
  C\# peuvent en effet être compilés vers la représentation
  intermédiaire de LLVM, un model-checker utilisant cette dernière est
  alors compatible avec tout ces langages.}.

La programmation impérative consiste à faire évoluer l'état du programme,
définis par la valeur de ses variables, à l'aide d'instruction. L'état d'un
programme est défini par l'état de la mémoire à laquelle il a accès. On peut
donc modéliser un programme par un système de transitions, dont les états sont
une partition de l'ensemble des états du programme.
Un état du modèle est donc principalement défini par :

\begin{itemize}
\item
  la configuration du tas du programme ;
\item
  la configuration de la pile de chaque thread ;
\item
  la valeur du pointeur d'instruction de chaque thread.
\end{itemize}

Les instructions permettant de faire évoluer l'état du programme sont
représentées par des transitions entres les états du modèle. Une transition
représente plus précisément l'action d'une instruction atomique du programme sur
les trois zones mémoires citées précédemment. Les transitions peuvent aussi
dépendre de facteurs externes, comme les entrées du programme.

Dans le cadre du model-checking logiciel, deux hypothèses sont fréquemment
faites sur le système :

\begin{itemize}
\item
  la consistance séquentielle. On considère alors que les écritures et
  les lectures mémoire ont lieu dans l'ordre où les instructions sont
  rencontrées dans une trace d'exécution. En pratique, cette hypothèse
  n'est pas toujours vérifiée. Les compilateurs et les processeurs
  peuvent modifier l'ordre de ces opérations pour optimiser un
  programme. On parle alors de modèle mémoire \emph{faible}.
\item
  la sémantique d'entrelacement. Dans le cas d'un système multi-thread,
  on considère que les traces d'exécution possibles sont produites par
  un entrelacement des instructions atomiques de chaque thread. Cette
  hypothèse n'est pas valide si le programme est exécuté par plusieurs
  processeurs : il est alors possible d'exécuter plusieurs instructions
  simultanément, ce qui peut produire des traces d'exécution
  supplémentaires.
\end{itemize}

\paragraph{Exemple}

Considérons le programme suivant, formé de deux threads.

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Thread 1, frame=tlrb]
a <- 1
a <- 2
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Thread 2,frame=tlrb]
c <- 1
d <- a + c
\end{lstlisting}
\end{minipage}

Ce programme contient trois variables, \lstinline!a!, \lstinline!c! et
\lstinline!d!, et deux threads. Les états du systèmes sont donc définis par les
valeurs de ces variables et la position des pointeurs d'instruction de chaque
thread. On peut modéliser ce programme par le système de transitions en Figure
\ref{fig:model_example}.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{model_example}
\end{center}
\caption{Système de transition modélisant un programme simple.}
\label{fig:model_example}
\end{figure}

\subsection{Non-determinisme}

Un système est rarement complètement déterministe. De nombreux facteurs (les
données en entrée du système, l'instant où un évènement à lieu, la réussite des
allocations mémoire, la concurrence) tendent généralement à rendre l'évolution
d'un système non-deterministe.

Face à un choix non-déterministe, les techniques de model-checking doivent
explorer toute les alternatives possibles.

Lors de la modélisation, certaine sources de non-determinisme sont ignorées.
Elles sont alors remplacées par une exécution déterministe.
C'est généralement le cas pour les appels systèmes ayant la possibilité
d'échouer (les allocations de mémoire, par exemple).

Pour représenter les évènements et les paramètres extérieurs du programme,
une fonction simulant le non-determinisme est généralement mise à disposition
de l'utilisateur par les outils de model-checking.

\subsection{Explosion combinatoire}

Le nombre d'états d'un programme augmente exponentiellement selon de nombreux
paramètres (nombre de variables du programme, taille des types de données, degré
de concurrence\dots). Il peut éventuellement être infinis si des appels de
fonctions ou de l'allocation dynamique de mémoire entre en jeu. Cependant, afin
de vérifier un système, un model-checker doit explorer l'ensemble de ces états.
Cette tache devient donc extrêmement coûteuse en temps et en mémoire quand le
nombre d'état devient trop important.
Ce problème, nommé l'explosion combinatoire, est la principale limite du
model-checking.

Le non-determinisme est une des principales raison de l'explosion combinatoire :
le nombre d'exécution est exponentiel selon le nombre de choix non-deterministe.

Cela explique les difficultés rencontrées par les techniques de model-checking
face aux programme concurrents : l'ordonnancement entre les instructions est
non-déterministe. Il existe un nombre d'entrelacements exponentiel en fonction
du nombre d'instructions du programme.

Les différents algorithmes de model-checking utilisent tous des
techniques afin de limiter l'explosion combinatoire. Elle reste
cependant le plus grand obstacle rencontré par le model-checking et
limite le passage à l'échelle de la plupart des techniques.

\section{Spécification}\label{sec:specification}

Afin de vérifier un système, il faut tout d'abord établir ce que signifie être
correct pour ce système. Un ingénieur en charge du design d'un système à
généralement une connaissance informelle de la manière dont le système doit se
comporter. Il est alors nécessaire de traduire cette connaissance d'une manière
non ambiguë et compréhensible par des outils. On réalise pour cela une
spécification du système.

Une spécification est constituée d'un ensemble de propriétés que le système doit
respecter. Les propriétés représentent des invariants logiques que le système
doit respecter. Si l'invariant est brisé, une erreur est présente : le système ne
se comporte pas de la manière attendue. Un outil de vérification peut alors inspecter
un système afin de vérifier si l'ensemble de la spécification est respecté.

Une spécification peut prendre de nombreux aspects : il existe des langages de
spécification (UML par exemple), elle peut être constitué de formules logiques
sur les variables composants le système, prendre la forme d'un système de
transitions\dots Un langage de programmation constitue en lui même une
spécification bas niveau du comportement d'un programme.

Les propriétés d'une spécification se répartissent en plusieurs catégories. Une
propriété peut être un comportement généralement attendu pour le type de système
concerné. Par exemple, on attend généralement d'un programme qu'il ne contienne
pas de comportement indéterminé. Une propriété peut aussi être spécifique au
système et à son comportement. On peut par exemple spécifier qu'une variable ne
doit jamais dépasser un certain seuil.

\subsection{\texorpdfstring{Propriétés ``built-in''}{Propriétés built-in}}

Certaines propriétés sont fortement --- si ce n'est toujours --- désirables
pour une catégorie de systèmes. Un model-checker ciblant cette catégorie
de systèmes peut alors implémenter la vérification de ces propriétés
nativement, sans qu'il soit nécessaire de les spécifier. On parle alors
de propriétés \emph{built-in}.

Dans le cas du model-checking logiciel, des propriétés built-in
classiques sont la vérification de la validité des pointeurs et des
opérations arithmétiques, l'initialisation des variables, et, de manière
plus générale, l'absence de tout comportement ne respectant pas la norme
du langage.
Dans le cas de programmes concurrents, on cherche généralement à s'assurer de
l'absence de deadlock (lorsque tout les threads du programme sont bloqué par une
condition, et que le système ne peut plus évoluer) et de data-races (plusieurs
accès simultanés à une même adresse mémoire, dont au moins un en écriture).

Les propriétés built-in sont souvent des propriétés qu'il serait difficile à
l'utilisateur de spécifier, parce qu'elles impliquent la plupart des variables
du système.

Pour vérifier des propriétés plus spécifiques au système (des propriétés
fonctionnelles par exemple, qui portent sur le résultat que le système doit
produire) il est cependant nécessaire de permettre à l'utilisateur d'exprimer
lui même la spécification.

\subsection{Assertions}

Dans un article de son blog, John Regehr aborde le sujet des assertion
\cite{assertion_regehr}. Il reprend en particulier la définition suivante :

\begin{quotation}
\selectlanguage{english}
An assertion is a Boolean expression at a specific point in a program which will
be true unless there is a bug in the program.
\hfill \cite{assertion_regehr}
\end{quotation}

%% \begin{quotation}
%% ASSERT(expr)

%% Asserts that an expression is true. The expression may or may not be evaluated.

%% If the expression is true, execution continues normally.
%% If the expression is false, what happens is undefined.
%% \hfill \cite{assertion_regehr}
%% \end{quotation}

\selectlanguage{french}

Cette définition présente les assertions comme un mécanisme de spécification
exécutable. Si une assertion n'est pas respectée, une erreur est présente dans
le programme. Les assertions sont présentes dans la plupart des langages de
programmation. Elles ont été naturellement reprises par les méthodes de
vérification formelle, dont le model-checking logiciel.

Les assertions permettent de vérifier des propriétés d'accessibilités. Ces
propriétés consistent à vérifier si il est possible d'atteindre un état donné du
modèle. Cet état est appelé un état d'erreur. On peut aussi considérer
l'accessibilité d'un ensemble d'états d'erreurs.

Les propriétés d'accessibilités sont des propriétés relativement simples :
déterminer si un état est un état d'erreur ne dépend que de cet état. Un
programme contient donc une erreur dès qu'il est possible d'atteindre un état
d'erreur, indépendemment des états et des transitions emprunté au cours de
l'exécution. Une propriété d'accessibilité peut ainsi être déterminée par une
exploration (en largeur par exemple) du système.

Dans un programme, une assertion prends la forme d'une instruction telle que :
\lstinline!assert(condition);!.
Si elle est exécutée et que la condition est évaluée à vraie, alors l'exécution
du programme continue normalement.
Sinon, le programme a atteint un état d'erreur. Sont comportement est alors
indéterminé, bien que le comportement le plus fréquent soit de stopper son
exécution.

Plus formellement, l'assertion \lstinline!assert(c)! désigne comme étant des
états d'erreur tous les états tels que :

\begin{itemize}
\item
  un des pointeurs d'instruction du programme pointe sur l'assertion
\item
  l'expression \lstinline!c! s'évalue à faux
\end{itemize}

Dans le code suivant, une assertion permet ainsi spécifier que la variable
\lstinline!b! doit être non nulle. Dans le cas contraire, une erreur
arithmétique (division par zéro) aurait lieu à la ligne suivante.

\begin{lstlisting}[language=C]
int int_div(int a, int b) {
    assert(b != 0);
    return a / b;
}
\end{lstlisting}

Les assertions sont très utilisées en raison de leur simplicité.
Elles peuvent de plus être placées en tant que spécification pour un outil de
vérification, ou permettre de signaler une erreur dans une version exécutable
du programme (bien qu'il ne faille pas les confondre avec un mécanisme de
gestion d'erreurs).

Cependant, le pouvoir d'expression des assertions est limité. Toutes les
propriétés d'accessibilités ne peuvent pas être exprimée par une assertion : il
n'est par exemple pas possible d'utiliser dans la condition d'une assertion des
variables hors du contexte courant. Il n'est pas non plus possible d'exprimer un
problème d'exclusion mutuelle : il faudrait pour cela référer à la position des
autres pointeurs d'exécution du code, ce qui n'est pas possible à l'aide d'une
assertion.

\subsection{Logique temporelle}

Pour exprimer des propriétés plus complexes et en particulier des propriétés qui
portent sur l'ensemble d'une trace d'exécution et l'ordre d'apparition de
certains évènements, il est nécessaire d'utiliser une logique temporelle.

Supposons que notre système soit le code d'un distributeur automatique.
On voudrait s'assurer que le distributeur ne délivre jamais le produit
avant que le client ait payé, ce qui va revenir dans le code à vérifier
que la fonction \lstinline!livrer_produit! (qui commanderait au système
de donner au client l'objet commandé) n'est jamais appelée avant la
fonction \lstinline!accepter_paiement! (qui validerait que le paiement a
été correctement effectué), au cours d'une transaction. Des assertions
permettent de déterminer si chacune de ces fonction est atteinte, mais
sans introduire des variables auxiliaires, il n'est pas possible de
déterminer l'ordre des appels.

Les logiques temporelles permettent d'exprimer ce type de propriétés. On
peut ainsi spécifier, pour un programme, des propriétés sur la
succession des états d'une trace d'exécution.

Ci-dessous sont listés quelque uns des schémas de propriétés les plus
courantes. D'avantage sont présenté par \citep{LTL_scheme}. \(p\) est une
propriété portant sur les états du système.

\begin{itemize}
\item
  propriété de sûreté : tout les états atteints pendant l'exécution
  vérifient la propriété \(p\).
\item
  propriété d'accessibilité : en un temps fini, un état vérifiant la
  propriété \(p\) est atteint.
\item
  propriété de vivacité : à partir de tout les états de la trace, on
  atteindra en temps fini un état vérifiant la propriété \(p\).
\item
  propriété d'équité : TODO
\end{itemize}

Les logiques temporelles les plus utilisées sont LTL (Linear Temporal
Logic) et CTL (Computation Tree Logic).

LTL et CTL différent principalement par leur vision de l'ensemble des
traces d'exécution. LTL considère chaque trace indépendamment. Un
système est valide par rapport à une propriété LTL si toutes ses traces
d'exécution respectent la propriété. CTL considère l'ensemble des traces
comme un arbre et permet, à chaque noeud, de quantifier universellement
ou existentiellement sur ses successeurs.

Le pouvoir d'expressivité de LTL et CTL n'est ni équivalent, ni même comparable.
En effet, LTL ne permet pas de quantifier existentiellement : une formule CTL
utilisant une quantification existentielle n'a donc pas d'équivalent en LTL. La
réciproque peut être présentée à l'aide de la propriété LTL \(F (p \land X p)\)
(pour toutes les traces, on atteint un état vérifiant \(p\) et dont le
successeur vérifie \(p\)) n'a pas d'équivalent dans CTL. La formule CTL \(AF (p
\land AX p)\) (quelque soit le chemin emprunté, on atteint un état vérifiant
\(p\) et dont tout les successeurs vérifient \(p\)) pourrait sembler un bon
candidat, mais la Figure \ref{LTL_vs_CTL} présente un modèle vérifiant
\(F (p \land X p)\) mais ne vérifiant pas \(AF (p \land AX p)\).

\begin{figure}
\begin{center}
\includegraphics[width=0.4\textwidth]{LTL_CTL_non_equivalent.png}
\caption{Modèle vérifiant \(F (p \land X p)\) mais pas \(AF (p \land AX p)\).}
\label{LTL_vs_CTL}
\end{center}
\end{figure}

Par la suite, nous allons nous concentrer sur LTL, car cette logique est
plus utilisée dans le cadre du model-checking logiciel.

\textbf{TODO} : Justifier. Voir articles utilisé dans la thèse de
J.Morse

\subsection{LTL : Logique Temporelle Linéaire}

\textbf{TODO} : référence

La définition de LTL ajoute deux opérateurs temporels à la logique
classique, \(next\) (\(X\)) et \(until\) (\(U\)). La syntaxe d'une
formule LTL est définie de la manière suivante, pour \(\phi\) et \(\psi\)
deux formules LTL :

\[
\phi, \psi := \text{true }| \text{ false } | \text{ p } |
             \phi \land \psi | \lnot \phi | X \phi | \psi U \phi
\]

\(p\) est une proposition sur l'état du système. On nommera par la suite
ces propriétés des \emph{proposition atomiques}. On identifiera aussi
une proposition atomique avec sa fonction d'évaluation, c'est à dire la
fonction qui indique si un état du système vérifie la propriété ou non.

Étant donnée une trace d'exécution infinie \(s = (s_0, s_1, ...)\), LTL a
la sémantique suivante :

\[
\begin{aligned}
s \models p & \equiv s_0 \models p \\
s \models X \phi & \equiv (s_1, s_2, \dots) \models \phi \\
s \models \phi U \psi & \equiv \exists k, (s_k, s_{k+1}, \dots) \models \psi
                        \land \forall i <= k, (s_i, s_{i+1}) \models \phi \\
\end{aligned}
\]

\(\lnot\), \(\land\), \(true\) et \(false\) s'interprètent de la manière
usuelle.

Une trace d'exécution est un modèle d'une proposition atomique si sont premier
état est un modèle de la proposition atomique.
L'opérateur \(next\) signifie donc que la propriété LTL passé en
paramètre doit être valide sur l'état suivant de la trace, tandis que
l'opérateur \(until\) signifie que la première propriété passé en
paramètre doit être valide sur les état rencontrés jusqu'à ce que un
état vérifie la seconde formule.

A partir de ces opérateurs base, on définit les opérateur \(\lor\),
\(\implies\), \dots de la manière classique. On définit aussi les
opérateurs temporels \(always\) (\(G\)), signifiant qu'une propriété est
vrai pour tout les états d'une trace et \(finally\) (\(F\)), signifiant
qu'un état vérifiant une propriété est atteint dans le futur.

\[
\begin{aligned}
F p & \equiv \text{true} U p \\
G p & \equiv \lnot F (\lnot p)\\
\end{aligned}
\]

Enfin, on définit un système comme étant valide par rapport à une
formule LTL si toutes les exécutions de ce système sont des modèles de
la formule.

\subsection{Automates de Büchi}

Vérifier si un système respecte une proposition LTL demande d'être capable de
manipuler efficacement ces dernières. On utilise pour cela les automates de
Büchi. Ils permettent de représenter une propriété LTL. Sous cette forme, elles
sont plus simple à manipuler pour un model-checker. Toute formule LTL peut être
représentée par un automate de Büchi. Il existe des algorithme pour construire
efficacement et automatiquement cet automate\citep{ltl2ba}.

Afin de vérifier si un système respecte une propriété LTL, une méthode classique
est de construire un automate de Büchi qui représente la négation de cette
formule LTL et d'explorer la composition entre cet automate et le système de
transitions modélisant le système. Un chemin acceptant représente alors une
exécution du système qui viole la propriété.

\paragraph{Automates de Büchi}
Un automate de Büchi est un automate qui accepte un langage de mots
infinis. Formellement, un automate de Büchi est un quintuplé
\(B = (S, \Sigma, I, \delta, F)\), avec :

\begin{itemize}
\item
  \(S\) un ensemble d'état ;
\item
  \(\Sigma\) un alphabet ;
\item
  \(I \subset S\) est un ensemble d'états initiaux ;
\item
  \(\delta \subset (S, \Sigma, S)\) est la relation de transition ;
\item
  \(F \subset S\) est l'ensemble des états finaux.
\end{itemize}

Un calcul (les mots chemin ou trace sont aussi utilisés) dans \(B\) est une
suite infinie de transitions consécutives \(c \in \delta^\omega\), dont l'état
de départ est un état initial :

\[
c = (s_0, a_0, s_1)(s_1, a_1, s_2)\dots(s_n, a_n, s_{n+1})\dots
\]

L'étiquette de ce chemin est le mot infini \(a = (a_0, a_1, \dots, a_n) \in
\Sigma^\omega\). Le chemin \(c\) est réussi si et seulement si il passe une
infinité de fois par un état final de \(B\).

L'automate \(B\) accepte un mot \(a\) si et seulement si
il existe un calcul réussi dans \(B\) ayant le mot \(a\) pour étiquette.

Pour représenter une formule LTL, on prend \(\Sigma = 2^P\), avec \(P\)
l'ensemble des propositions atomiques de la formule. Une lettre de
l'alphabet représente ainsi une configuration des propositions atomiques
du système.

\paragraph{Exemples}

La figure \ref{fig:buchi_example} présente les automates de Büchi pour trois propriétés
LTL simples : \(Gp\), \(F(p \lor q)\) et \(G(Fp)\). Seule la partie accessible des automates
est représentée, et les transitions ayant les même sources et destinations sont fusionnées,
leur étiquette étant remplacées par une garde sous la forme d'une expression logique.

\begin{figure}
\begin{center}
\includegraphics[height=.17\textheight]{buchi_1.png}
\includegraphics[height=.3\textheight]{buchi_3.png}
\includegraphics[height=.3\textheight]{buchi_2.png}
\end{center}
\caption{Automates de Büchi pour les formules LTL $G p$, $F(p \lor q)$ et
$G(F p)$.}
\label{fig:buchi_example}
\end{figure}

\paragraph{Automate produit}

Soient un automate de Büchi \(B = (S_B, \Sigma, I_B, \delta, F_B)\) représentant
une propriété LTL \(\phi\) et un système de transitions \(T = (S_T, \rightarrow,
I_B)\) modélisant un système.

L'automate produit de \(B\) et \(T\) est définit comme étant \(P = (S_P, \Sigma,
I_P, \delta_P, F_P)\), avec :

\begin{itemize}
\item
  \(S_P = S_B \times S_T\)
\item
  \(I_P = I_B \times I_T\)
\item
  \(F_P = F_B \times S_T\)
\item
  \(((p, q), s, (p', q')) \in \delta_P\) si et seulement si :

  \begin{itemize}
  \item
    \((p, p') \in \rightarrow\)
  \item
    \((q, s, q') \in \lambda\)
  \item
    \(p \models s\)
  \end{itemize}
\end{itemize}

Un mot est accepté par l'automate produit si et seulement si il représente
une exécution valide dans le modèle du système et qu'il appartient au langage
de l'automate de Büchi.
L'automate produit \(P\) reconnaît donc exactement le langage des exécutions du
modèle \(T\) qui vérifient la propriété LTL représentée par l'automate de
Büchi \(B\).

\paragraph{Vérifier une propriété LTL}

Vérifier si le modèle \(T\) respecte la propriété \(\phi\), revient à calculer
si le langage des exécutions valide de \(T\) est inclut dans le langage de
l'automate de Büchi \(B\). Cependant, vérifier une inclusion est une opération
complexe. Il est plus simple de calculer si langage est vide ou non. On va donc
reformuler le problème : on va chercher à déterminer si le langage \(L\) des
exécutions valident dans \(T\) et ne respectant \emph{pas} \(\phi\) est vide.
Si c'est le cas, le système est correct. Sinon, une erreur est présente et les
éléments de \(L\) représentent des contre-exemples.

Pour calculer le langage \(L\), on va construire le produit entre le système de
transitions du modèle et l'automate de Büchi représentant la \emph{négation} de
\(\phi\). Le langage de l'automate produit est alors constitué des exécutions valides du
modèle qui ne respectent pas \(\phi\), soit \(L\).

Il suffit alors d'explorer l'automate produit. Si il est possible de, à partir
de l'état initial, atteindre un cycle contenant un état final, alors, \(L\)
n'est pas vide : il contient au moins le mot composé par l'étiquette du chemin
allant jusqu'au cycle et d'une infinité de répétition de l'étiquette du cycle.
Ce correspond à une exécution du système qui viole la propriété \(\phi\), et
pourra être servir de contre-exemple à l'utilisateur.

L'encodage de propriétés LTL à l'aide des automates de Büchi permet ainsi de
vérifier des propriétés complexes sur les modèles. Cependant, la taille d'un
automate de Büchi augmente exponentiellement avec la profondeur de la formule
qu'il représente. Dans le cas de formules de grande taille, il peut donc devenir
problématique de générer l'automate. Sa taille et son aspect non-déterministe
viennent renforcer le problème d'explosion combinatoire déjà rencontré par les
techniques de model-checking.

\section{Techniques et outils de model-checking}
\label{sec:techniques-et-outils-de-model-checking}

Différents algorithmes sont utilisés par les outils de model-checking
afin d'explorer l'ensemble des états d'un modèle. Afin de lutter contre
l'explosion combinatoire, ils établissent des compromis au niveau de la
précision de la vérification et du type de propriétés qu'ils prennent en charge.
Leurs performances dépendent aussi fortement de la
structure du programme : les boucles, le non-determinisme ou la gestion
de la concurrence sont plus ou moins bien supportés selon
les algorithmes.

À l'exception des techniques de séquentialisation, ces algorithmes ont été
initialement appliqué à des programme séquentiels. Le support des programmes
concurrents est venu ensuite\footnote{Les algorithmes inspirés du model-checking
  de composants électroniques supportent des modèles concurrent depuis
  longtemps. Cependant, le support de la concurrence pour le model-checking
  logiciel a été ralentit par l'explosion combinatoire}.
Ce dernier n'est pas forcément complexe, d'un point de vu théorique : un
programme multi-thread peut s'exprimer comme un système de transitions
non-déterministe. Les model-checkers sont capables de vérifier des modèles
non-déterministe --- ils sont utilisés pour simuler les entrées possibles d'un
système par exemple --- les algorithmes de model-checking peuvent donc
théoriquement être étendus.
Le problème est bien plus complexe en pratique, en raison des contraintes de
temps et de mémoire que rencontrent les model-checker. En raison de l'explosion
combinatoire provoquée par le nombre exponentiel d'entrelacements possibles
entre les threads, il est difficile de concevoir un algorithme performant.

Nous présentons dans cette partie les principaux algorithmes utilisés dans le
cadre du model-checking de logiciel multi-thread, ainsi que certains des outils
qui les implémentent. Pour chaque algorithme, nous avons choisi les outils qui
nous ont parus les plus aboutis et ceux qui présentaient une approche originale.
Pour chaque algorithme et outil, nous tentons de mettre en valeur ses points
forts, ses faiblesses et ses spécificités.

\subsection{Model-checking explicite}

Le model-checking explicite consiste à énumérer individuellement les
états accessibles du modèle afin de les explorer. Le modèle prend la
forme d'un système de transitions et son exploration est réalisée à
l'aide d'algorithmes de graphes (exploration en largeur ou en
profondeur\dots).

Les algorithmes de model-checking explicite modélisent le programme par un
système de transitions. Ils construisent et explorent ce système de transitions
à la volée : partant de l'état de départ, les successeurs sont déterminés à
partir des instructions du programme. Ils sont alors explorés et ainsi de suite.
Pour ne pas explorer plusieurs fois un même état (l'exploration entrerait alors
dans un cycle infini), il est nécessaire de stocker les états du chemin
emprunté.

Le model-checking explicite est extrêmement vulnérable à l'explosion
combinatoire. Les états accessibles du système sont examinés individuellement.
Si ils sont en nombre infinis, une analyse peut ne pas terminer. Le stockage des
états explorés peut aussi devenir problématique. Plusieurs techniques existent
pour réduire l'impact de l'explosion combinatoire.

\paragraph{Stateless model-checking}
Certain outils choisissent de ne pas maintenir la liste des états
visités afin de ne pas être limité par l'utilisation de la mémoire. On
parle alors de \emph{stateless model-checking}. Ces outils ne sont pas
capables de détecter un cycle dans le programme à analyser. Il est donc
nécessaire que toutes les exécutions du programme à analyser terminent.

\paragraph{State hashing}
Le \emph{state hashing} consiste à ne conserver qu'une valeur de hachage des
états visités, et non pas l'état complet. L'utilisation de la mémoire est ainsi
réduite, et les performances peuvent être améliorées par l'utilisation de
structures de données capables de rechercher un élément de manière efficace
(ensemble ordonné, \dots). Cependant, il est possible (bien que très peu
probable) que deux états aient la même valeur de hachage. Ces états sont alors
considérés comme égaux, ce qui peux mener à un résultat faux de l'analyse.
Le state hashing rends donc les model-checker incomplets.

\paragraph{Runtime model-checking}
Certains outils explorent l'espace d'états en se basant sur des
exécutions réelles du programme. Le modèle est alors le programme lui
même. Son exécution est contrôlée par le model-checker, qui fixe le
non-déterminisme de chaque exécution. Cette approche permet de
bénéficier des performances réelles du programme lors de l'exploration,
cependant le backtracking est plus compliqué : les outils de runtime
model-checking relancent en général une exécution du programme à tester
depuis l'état initial chaque fois qu'il est nécessaire de revenir à un
état précédent. Il est aussi complexe de mémoriser les états explorés,
cette technique est donc souvent combinée avec le \emph{stateless model
checking}.

\paragraph{Réduction par ordre partiel}
Les techniques de réduction par ordre partiel visent à réduire le nombre de
chemin à explorer dans un système concurrent. Elles permettent de supprimer les
chemins équivalents par rapport aux propriétés à vérifier, souvent en supprimant
des changements de contextes entre des instructions indépendantes. Un cas simple
de réduction consiste à regrouper en un bloc atomique une série d'instruction
manipulant uniquement des variables locales. L'entrelacement de ces instructions
avec d'autres threads n'a pas d'impact sur leur résultat, on peut donc conserver
uniquement l'ordonnancement consistant à les exécuter sans changement de
contexte.

La plupart des variantes ci-dessus sont aussi utilisées par les autres
algorithmes que nous présentons par la suite, en particulier les
techniques de réduction par ordre partiel. Cependant, le model checking
explicite est particulièrement dépendant de ces techniques afin de
gagner en performances.

La principale force du model-checking explicite est sa précision. Explorer
l'ensemble des états de manière explicite permet de vérifier la plupart des
propriétés, spécifiée à l'aide d'assertions ou par une formule LTL. Cependant,
il est extrêmement dépendant des techniques de réduction et a plus de
difficultés face à des programmes de grande taille.

\subsubsection{Outils}

SPIN\cite{SPIN} est l'un des premiers projets de model-checking
explicite. Il permet de vérifier des propriétés de la logique temporelle
LTL sur des modèles exprimés en \bsc{PROMELA}. SPIN supporte nativement
les modèles concurrents et implémente de nombreuse méthodes de réduction
(ordre partiel, bit-state hashing\dots). SPIN ne supporte pas le langage
C nativement, cependant des travaux ont été menés afin de traduire C
vers \bsc{Promela}\cite{jiang_C_to_Promela}, ce qui permet à SPIN de
vérifier un programme en C de manière indirecte.

Pancam\cite{Pancam} se base sur SPIN pour vérifier du bytecode
LLVM\footnote{le bytecode LLVM peut être produit à partir d'un code C à
  l'aide d'un compilateur tel que CLANG ou GCC}. Pancam exécute le
bytecode LLVM dans une machine virtuelle et utilise SPIN comme un
moniteur d'exécution afin de générer les différents entrelacements à
explorer.

\lstinline!inspect!\cite{inspect} vérifie du code C et C++
multithread en se basant sur un algorithme de runtime model-checking
avec une exploration \emph{stateless}. \lstinline!inspect! instrumente
le programme à vérifier par des instructions lui permettant de
communiquer avec un ordonnanceur, selon une architecture client/serveur.
Le programme est ensuite exécuté à plusieurs reprises afin d'explorer les
différents entrelacements.

Divine\cite{Divine_3_0} est un model-checker capable de vérifier des
propriétés LTL et des propriétés d'accessibilités. Il se base sur un
langage interne, DVE. Il est capable de traiter du bytecode LLVM en le
traduisant vers DVE, ce qui lui permet de supporter des langages comme C
et C++. La particularité de Divine est de mettre en place une analyse
concurrente et distribuée afin d'améliorer ses performances. Il utilise
aussi des méthodes de réduction de l'espace d'état (compression de
chemins, réduction par ordre partiel).

On retrouve à travers ces outils le besoin de performance des outils de
model-checking explicite. Divine est implémenté dans une architecture
concurrente pour améliorer ses performances, alors que \lstinline!inspect! et
Pancam se basent sur du runtime model-checking. SPIN, \lstinline!inspect!,
Pancam et Divine sont tous vérifier des violations d'assertions et des
propriétés built-in, comme les deadlocks et les data-races, cependant, seul
Divine et SPIN sont capable de vérifier des propriétés LTL.
\lstinline!inspect! nécessite un système fermé, et n'est pas capable de gérer le
non-déterminisme. Il est donc dépendant d'une suite de tests pour fixer les
paramètres du programme à vérifier.
Divine est arrivé sixième lors de l'édition de 2016 de la compétition de
vérification logicielle SV-COMP\citep{SVCOMP2016} (les autres outils présentés
ci-dessus n'ont pas participé à ces compétitions).
