\chapter{Exprimer la spécification par des assertions à l'aide d'une
instrumentation}\label{sec:Theme2}

Nous avons présenté un formalisme de spécification basé sur \ac{LTL} dans le
Chapitre~\ref{sec:Theme1}. Notre objectif est maintenant d'établir un outil
permettant de vérifier un programme concurrent en C, spécifié dans ce
formalisme.

Construire un outil de model-checking performant et adapté à notre spécification
dépasse de loin le cadre de cette maîtrise. Nous allons donc nous baser sur les
outils existants. Cependant, la plupart des outils de model-checking pour des
programmes concurrents en C ne supportent pas \ac{LTL}, alors que notre
spécification est basée sur cette logique temporelle. Adapter un model-checker
sera donc une tâche complexe.

Cependant, presque tous les model-checkers logiciels supportent les assertions.
Nous avons par conséquent mis en place une transformation source à source du
système. À partir des sources d'un système et de sa spécification, elle produit
un programme instrumenté, contenant des assertions, tel que la validité de ce
programme instrumenté par rapport aux assertions corresponde à celle du
programme initial par rapport à sa spécification.

Construire une transformation de source à source présente de plus un certain
nombre d'avantages. Elle est en grande partie indépendante du model-checker
utilisé pour effectuer la vérification, ce qui permet d'obtenir un outil
compatible avec plusieurs model-checker en arrière plan. On peut ainsi les
comparer et sélectionner le
plus adapté pour un problème spécifique. Utiliser une instrumentation du code
simplifie aussi les tâches d'implémentation, en nous évitant de composer avec le
code d'un système préexistant et la représentation interne d'un model-checker.
Cependant, ce choix a aussi des inconvénients. En particulier, une
instrumentation représente une perte de précision et de performance par rapport
à un traitement direct : des variables et des instructions sont ajoutées dans le
système et vont être traitées comme n'importe quelle instruction par les
model-checkers en backend, alors qu'elles suivent une logique qui pourrait être
utilisée pour les traiter plus efficacement.

La transformation de source à source que nous proposons s'inspire fortement de
celle mise en place dans \cite{morse_ltl}. Elle se base sur la composition d'un
automate de Büchi représentant la négation de la propriété \ac{LTL} à prouver
avec le programme à valider. Un model-checker doit ensuite être utilisé pour
explorer le produit du système avec l'automate. La composition du système avec
un automate de Büchi est une technique classique pour le model-checking de
propriétés LTL\cite{25_years_of_model_checking}. La particularité de notre
approche est de construire ce produit au niveau du code source du système, et
non pas au niveau de la représentation interne d'un model-checker (où le système
et l'automate sont vus comme des systèmes de transitions).

La figure~\ref{fig:baProduct_func} présente le fonctionnement de l'outil que
nous avons conçu, nommé \emph{baProduct}. Trois phases principales
apparaissent :

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
  \item Construire un automate de Büchi à partir de la spécification, et le
    convertir en code C ;
  \item Instrumenter le code source du système en entrée pour construire le
    produit entre le système et l'automate de Büchi ;
  \item Vérifier le code produit à l'aide d'un model-checker et analyser les
    résultats.
\end{enumerate}

\begin{figure}
\begin{center}
  \includegraphics[width=\textwidth]{baProduct_organization.png}
\end{center}
\caption{Schéma fonctionnel de baProduct}
\label{fig:baProduct_func}
\end{figure}

Dans la suite de ce chapitre, nous allons détailler ces trois étapes. Nous
présentons ensuite notre implémentation, puis une analyse de performances
sur une série d'exemples avec différents model-checkers utilisés pour les tâches
de vérification.

\section{Construction de l'automate de Büchi}

Nous reprenons une technique classique de vérification des propriétés \ac{LTL},
utilisée en particulier par SPIN\cite{SPIN} : construire un automate de Büchi
représentant la négation de la propriété \ac{LTL} et le composer avec le
système. Une exécution acceptée par le système résultant est un contre-exemple à
la spécification.

Mais alors que de manière générale, le programme à vérifier est représenté par
un système de transitions avant d'être composé avec l'automate de Büchi, nous
allons ici représenter l'automate de Büchi en C avant de le composer avec le
programme.

Des algorithmes efficaces et éprouvés permettent de construire l'automate de
Büchi représentant une formule \ac{LTL}\cite{ltl2ba}. Nous allons donc nous
concentrer sur l'implémentation d'un automate en C.

Cependant, vouloir vérifier des propriétés \ac{LTL} à l'aide d'une
instrumentation à une conséquence : il n'est possible de vérifier que des traces
finies. En effet, les model-checkers utilisent la présence de cycles dans les
traces infinies pour les traiter : une fois le cycle atteint, le comportement du
programme est totalement connu et il est possible de conclure si oui ou non, il
vérifie une spécification. Mais du point de vue d'une instrumentation, il n'est
pas possible de détecter un cycle, et il n'est donc pas possible de déterminer à
quel moment prononcer une conclusion pour une trace infinie : l'ensemble des
comportements du programme n'a peut être pas encore eu lieu, un nouveau
comportement pourrait modifier le verdict. Dans le cas d'une trace finie, par
contre, il suffit de conclure à la fin de la trace. Pour une instrumentation,
cela revient à placer une fonction de ``conclusion'' juste avant les points de
sortie du programme.

Nous allons donc pour la suite nous restreindre à des traces finies. Puisque
\ac{LTL} est définie sur des traces infinies, nous allons voir tout d'abord
comment interpréter une formule \ac{LTL} dans le cas d'une trace finie, avant
d'expliquer notre construction en C de l'automate de Büchi associé.

\subsection{Traces finies et logique à 4 valeurs de vérité}

Les propriétés \ac{LTL} ne sont pas définies sur les traces finies. Plusieurs
variantes de \ac{LTL} existent pour répondre à ce problème (LTL3, FLTL, RV-LTL,
infinite extension\ldots{}), aucune ne faisant consensus.

Nous avons choisi l'approche du \emph{stuttering} : l'état final de la
trace finie est répété à l'infini afin d'étendre la trace de manière
infinie. Cette approche correspond bien avec un programme qui, lorsqu'il
se termine, n'a pas de raison de voir son état évoluer. Elle a de plus
l'avantage de ne pas modifier les opérateurs \ac{LTL}, ce qui nous permet
d'utiliser les techniques de vérification pour \ac{LTL} sans modifications.
Une trace finie est un modèle d'une propriété \ac{LTL} dans la sémantique
avec \emph{stuttering} si et seulement si son extension infinie est un
modèle.

\paragraph{Exemple}
Soient \(p\) et \(q\) deux états d'un système. Soit la trace finie \(t =
pqpqpqp\). Alors, l'extension infinie de \(t\) est la trace \(t' =
pqpqpppppp\dots\).

\(t'\) ne vérifie pas \(G p\) mais vérifie \(F(G p)\), il en va donc de même
pour la trace finie \(t\).

Il faut cependant noter que les différentes variantes de \ac{LTL} pour des
traces finies diffèrent principalement par la prise en charge de
l'opérateur \emph{next}. Dans le cadre du software model-checking, le
sens donné à celui-ci est très variable et il est généralement
déconseillé de l'utiliser.

Une trace finie ne correspond pas toujours à une exécution réelle du système.
Il peut s'agir seulement d'un préfixe d'une exécution plus longue, par exemple,
le nombre d'itérations d'une boucle a pu être limité. La prolongation de la
sémantique d'extension infinie ne reflète donc pas forcément le comportement
réel du système.

\paragraph{Exemple}
La trace \(t = pqpqpqp\) de l'exemple précédent est peut-être le préfixe d'une
trace \(t'' = pqpqpq\dots pq\dots\), qui aurait été interrompue. Cette trace ne
vérifie pas la propriété \(F (G p)\), contrairement à \(t'\), l'extension infinie de \(t\).

Pour tenir compte de ce comportement, il est possible de raffiner davantage les
résultats en faisant la distinction entre deux types de traces finies :

\begin{itemize}
\item
  le préfixe fini est suffisant pour déterminer si la trace est un
  modèle de la formule ou non, quelque soit l'extension
  (\emph{stuttering} ou autre)
\item
  le préfixe fini n'est pas suffisant, le résultat dépend de l'extension
\end{itemize}

\paragraph{Exemple}
Le préfixe fini \(t = pqpqpqp\) est suffisant pour établir que \(t\) ne vérifie
pas \(G p\), quelque soit l'extension. Pour \(F (G p)\), cependant, nous avons
vu que le résultat dépend de l'extension choisie.

Nous avons de plus utilisé une logique à 4 valeurs de vérité, comme
décrite dans \cite{morse_ltl}. Nous pourrons ainsi, selon la catégorie d'une
trace, affecter des valeurs de vérité différentes.

Étant donné une propriété et un automate de Büchi associé à cette propriété, on
définit les quatre valeurs de vérité par :

\begin{itemize}
\item
  \textbf{True} : utilisée lorsque, étant donnée une trace finie \texttt{t},
  toutes les traces ayant \texttt{t} pour préfixe sont acceptées par
  l'automate.
\item
  \textbf{Maybe true} : utilisée lorsque, étant donnée une trace finie
  \texttt{t}, l'extension infinie de \texttt{t} en répétant son
  dernier état est acceptée par l'automate.
\item
  \textbf{Maybe false} : utilisée lorsque étant donnée une trace finie
  \texttt{t}, l'extension infinie de \texttt{t} en répétant son
  dernier état est rejeté par l'automate mais que au moins une trace
  ayant \texttt{t} pour préfixe est acceptée.
\item
  \textbf{False} : utilisée lorsque, étant donnée une trace finie \texttt{t},
  toutes les traces ayant \texttt{t} pour préfixe sont rejetées par
  l'automate.
\end{itemize}

Les deux valeurs \emph{True} et \emph{False} permettent de conclure de manière
certaine, lorsque le résultat ne dépend pas de l'extension. Si le résultat
dépend de l'extension, les valeurs \emph{Maybe true} et \emph{Maybe false}
permettent d'indiquer que le résultat est relatif à la sémantique d'extension
infinie.

Dans les cas d'une conclusion \emph{Maybe true} ou \emph{Maybe false},
savoir si le programme a terminé ou non son exécution (i.e on a vérifié
l'exécution complète ou la vérification a été interrompue parce qu'une borne sur
la profondeur d'exploration a été atteinte) peut permettre de préciser le résultat.

\subsection{Implémentation de l'automate}

La génération d'un automate de Büchi en C est la première étape réalisée par
notre outil (étape 1 dans la Figure~\ref{fig:baProduct_func}). Cet automate doit
représenter la négation de la propriété \ac{LTL} présente dans la spécification,
et permettre de déduire un résultat dans la logique à 4 valeurs de vérité.
L'implémentation de cet automate reprend l'approche décrite dans
\cite{morse_ltl}.

Les états de l'automate sont indicés selon un ordre arbitraire. On réfère à un
état dans le code par son indice. La partie principale de l'implémentation de
l'automate est sa fonction de transition. Elle est implémentée à travers une
fonction C, qui permet de déterminer l'évolution de l'état de l'automate selon
l'état courant et les valeurs des propositions atomiques.

Nous utilisons les variables et fonctions suivantes pour construire l'automate :

\begin{itemize}
\item
  une variable globale, \texttt{ltl2ba\_state\_var}, contient l'état
  courant de l'automate sous la forme d'un entier (les états sont
  numérotés arbitrairement)
\item
  des variables globales, \texttt{ltl2ba\_atomic\_{name}} (où name est
  l'identifiant d'une proposition atomique), contiennent la valeur
  courante de chaque proposition atomique. Ces valeurs sont maintenues à
  jour pendant le déroulement du programme. Elles sont mises à jour par
  des instructions ajoutées dans le code du programme que nous
  détaillerons dans la partie sur l'instrumentation.
\item
  une fonction \texttt{\_ltl2ba\_transition} représente la fonction de
  transition de l'automate et fait évoluer l'état stocké dans
  \texttt{ltl2ba\_state\_var}. Étant donné l'état courant de
  l'automate, elle choisit de manière non déterministe une transition
  valide partant de cet état et met à jour l'état courant. Si aucune
  transition n'est valable, le mot est rejeté (et l'exploration courante
  est stoppée). Si l'état courant est un état puits acceptant, le mot
  est accepté et une erreur est immédiatement remontée (on rappelle que
  l'automate représente la négation de la propriété à vérifier, une
  trace acceptée par l'automate est donc un contre-exemple à la
  propriété).

  Cette fonction permet d'explorer l'automate de manière
  non déterministe. Une valeur non déterministe est produite l'aide de
  la fonction intrinsèque au model-checker, \texttt{nondet\_int()}. La
  transition à emprunter est désignée à l'aide de cette valeur. Le
  model-checker va alors explorer l'ensemble des évolutions possibles de
  l'automate. Les évolutions invalides sont immédiatement interrompues à
  l'aide d'hypothèses (commande \texttt{assume}).
\item
  une fonction \texttt{\_ltl2ba\_result} permet de déterminer le
  résultat d'une exploration. Elle est appelée après la dernière
  instruction du \texttt{main}. Elle se base sur l'état courant de
  l'automate et la valeur des propositions atomiques pour déterminer la
  valeur de vérité associée à cette exécution. Si une erreur est
  possible, elle est remontée au model-checker à l'aide d'une assertion.
  Les valeurs de vérité sont déterminées en utilisant des données
  précalculées par une analyse d'accessibilité dans l'automate de Büchi
  \cite{morse_ltl}.
\end{itemize}

Notre implémentation de l'automate de Büchi en C diffère de celle de
\cite{morse_ltl} par un point d'importance : dans \cite{morse_ltl}, l'automate
est implémenté dans un thread supplémentaire, utilisé comme un thread
observateur. La fonction de transition de l'automate est placée dans une boucle,
synchronisée avec le reste du code à l'aide d'une commande interne du
model-checker. Cette commande a été implémentée pour l'occasion. Dans notre cas,
la fonction de transition est représentée par une fonction dans le code, appelée
quand nécessaire par l'instrumentation. Cela nous permet de ne pas nous baser sur
une commande interne pour synchroniser l'automate avec le code et ainsi, de
supporter plus facilement différents model-checkers en backend.

\paragraph{Exemple}
L'automate pour la propriété LTL \(G p \implies F q\) est implémenté par
le code du listing~\ref{lst:C_automaton}.

\begin{lstlisting}[language=C, frame=single, label=lst:C_automaton,
    caption=Code de l'automate représentant \(G p \implies F q\)]
/* Status of atomic propositions */
_Bool _ltl2ba_atomic_p = 0;
_Bool _ltl2ba_atomic_q = 0;
/* Current state in the automaton */
int _ltl2ba_state_var = 0;
/* Transition function of the automaton */
void _ltl2ba_transition() {
  /* Non determinist choice of a transition */
  int choice = nondet_uint();
  /* Perform an action according to the current state */
  switch (_ltl2ba_state_var) {
  case 0:
    /* For each transition from this state... */
    if (choice == 0) {
      /* if atomic proposition verify the guard... */
      assume(!_ltl2ba_atomic_p);
      /* take the transition and update the current state */
      _ltl2ba_state_var = 0;
    } else if (choice == 1) {
      assume(1);
      _ltl2ba_state_var = 1;
    } else if (choice == 2) {
      assume(_ltl2ba_atomic_q);
      _ltl2ba_state_var = 0;
    } else {
      assume(0);
    }
    break;
  case 1:
    if (choice == 0) {
      assume(1);
      _ltl2ba_state_var = 1;
    } else if (choice == 1) {
      assume(_ltl2ba_atomic_q);
      _ltl2ba_state_var = 0;
    } else {
      assume(0);
    }
    break;
  }
}
/* States of the automaton from which every suffix is
   accepted by the automaton */
_Bool _ltl2ba_surely_accept[2] = {0, 0};
/* States of the automaton from which every suffix is
   rejected by the automaton */
_Bool _ltl2ba_surely_reject[2] = {0, 0};
/* For each combinations of automaton state and atomic
   proposition value, give the sttuter acceptance result. */
_Bool _ltl2ba_stutter_accept[8] = {1,0, 0,0, 1,1, 1,1,};
unsigned int _ltl2ba_sym_to_id() {
  unsigned int id = 0;
  id |= (_ltl2ba_atomic_p << 0);
  id |= (_ltl2ba_atomic_q << 1);
  return id;
};
/* Report results to the model-checker using assertions */
void _ltl2ba_result() {
  /* The automaton reject the execution: there is no error */
  _Bool reject_sure = _ltl2ba_surely_reject[_ltl2ba_state_var];
  /* The automaton accept the execution: there is an error */
  assume(!reject_sure);
  _Bool accept_sure = _ltl2ba_surely_accept[_ltl2ba_state_var];
  assert(!accept_sure, "ERROR SURE");
  /* The automaton stutter accept the execution:
     there may be an error */
  unsigned int id = _ltl2ba_sym_to_id();
  _Bool accept_stutter =
    _ltl2ba_stutter_accept[id * 2 + _ltl2ba_state_var];
  assert(!accept_stutter, "ERROR MAYBE");
  assert(accept_stutter, "VALID MAYBE");
}
\end{lstlisting}

Cet exemple permet de remarquer que le seul moyen de faire remonter un résultat
est à travers le déclenchement d'une assertion. La violation d'une assertion
met fin à une trace, il est donc important d'ordonner les assertions de manière
à ce que le résultat le plus fort soit le premier à être reporté pour qu'il ne soit pas masqué. De plus, certains model-checkers arrêtent d'explorer le modèle
dès qu'une erreur est reportée. Dans ce cas, il peut être nécessaire de réaliser
plusieurs vérifications successives en désactivant les assertions les plus
faibles, pour qu'un résultat faible ne masque pas un résultat plus fort présent
dans une trace future.

\section{Instrumentation du code}

Une fois l'automate implémenté, la seconde étape du processus est de construire
le produit entre le système et l'automate(étape~2 dans la
Figure~\ref{fig:baProduct_func}). Cela est réalisé par une instrumentation du
code, afin de maintenir à jour la valeur des propositions atomiques et d'appeler
la fonction de transition de l'automate.

Afin de minimiser l'instrumentation, la valeur d'une proposition atomique est
mise à jour uniquement lorsqu’un des paramètres dont elle dépend est modifié
(valeur d'une variable, entrée ou sortie de la zone de validité). La fonction de
transition de l'automate est appelée uniquement à ces occasions. L'opérateur
\ac{LTL} \emph{Next} a alors pour signification ``lors du prochain appel à la
fonction de transition'', c'est à dire la prochaine fois qu'une proposition
atomique est susceptible d'être modifiée.

Différents emplacements du code vont nécessiter une instrumentation, qui va
aussi dépendre du type de paramètre des propositions atomiques. Nous allons
expliquer l'instrumentation nécessaire dans ces différents cas.

\subsection{Frontière des zones de validité}

Les premiers points nécessitant une instrumentation sont les frontières
des zones de validité des propositions atomiques. Lorsqu'un pointeur
d'instruction atteint l'instruction portant le label d'entrée
(respectivement de sortie) d'une zone de validité, la proposition
atomique doit prendre la valeur calculée par sa fonction d'évaluation
(respectivement sa valeur par défaut).

Les listings~\ref{lst:instr_in1} et \ref{lst:instr_out1} présentent
l'instrumentation correspondant à l'entrée et à la sortie des zones de
validités. Ici, la proposition atomique \texttt{p} débute au label
\texttt{lbegin} et se termine au label \texttt{lend}.

\noindent\begin{minipage}{.47\textwidth}
  \begin{lstlisting}[language=C, frame=single, numbers=left,
    caption=Entrée d'une zone de validité (1),
    label=lst:instr_in1]
__atomic_begin();
ltl2ba_atomic_p = fp(..);
_ltl2ba_transition();
__atomic_end();
lbegin: ....;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.47\textwidth}
  \begin{lstlisting}[language=C, frame=single, numbers=left,
    caption=Sortie d'une zone de validité (1),
    label=lst:instr_out1]
__atomic_begin();
ltl2ba_atomic_p = {v_default};
_ltl2ba_transition();
__atomic_end();
lend: ....;
\end{lstlisting}
\end{minipage}

Toutes les instructions sont regroupées dans un bloc atomique (ouvert
par l'instruction \texttt{\_\_atomic\_begin()} et fermé par
l'instruction \texttt{atomic\_end()}) afin de ne pas générer
d'entrelacements supplémentaires dans le code et créer des chemins
d'exécutions pouvant mener à une conclusion erronée : toutes les
instructions de l'instrumentation doivent être réalisées de manière
atomique (sans changement de contexte possible) pour garantir un état
cohérent de l'automate. Si plusieurs entrées et sorties d'une zone de validité ont
lieu au même label, les instructions d'instrumentations sont toutes
réunies dans le même bloc atomique. La fonction de transition n'est
appelée qu'une seule fois, après l'actualisation de toutes les
propositions atomiques.

\subsection{Variables locales}

Passons à la seconde raison pouvant amener à modifier la valeur d'une
proposition atomique. Il s'agit de la modification d'une variable dont
dépend la proposition atomique, dans sa zone de validité (en dehors de
la zone de validité, la proposition atomique s'évalue toujours à sa
valeur par défaut, la modification d'une variable n'a donc pas
d'impact). Nous allons tout d'abord nous concentrer uniquement sur le
cas des variables locales à une fonction.

Si une variable locale est modifiée dans la zone de validité d'une
proposition atomique et que la valeur de la proposition atomique dépend
de la variable, il est toujours nécessaire d'instrumenter l'affectation.
Instrumenter ces appels est aussi suffisant (car nous ne considérons pas
les accès indirects aux variables). La variable étant locale, elle ne
peut s'échapper hors de son contexte : elle ne peut donc pas être
modifiée par une instruction hors de la zone de validité alors qu'un
pointeur d'instruction est dans la zone de validité.

On peut alors ajouter une instrumentation autour de l'affectation. Après
la modification de la variable, les propositions atomiques qui en
dépendent sont évaluées à nouveau. On tente ensuite d'effectuer une
transition dans l'automate de Büchi.

\begin{lstlisting}[language=C, frame=single, numbers=left,
  caption=Instrumentation pour une variable locale]
__atomic_begin();
v = ....;
ltl2ba_atomic_p = fp(v, ...);
_ltl2ba_transition();
__atomic_end();
\end{lstlisting}

L'affectation de la variable à sa nouvelle valeur et l'instrumentation
sont placées dans un même bloc atomique, afin de répercuter la modification de
l'état sans changement de contexte possible.

Contrairement à l'instrumentation à l'entrée et la sortie des zones de
validité, ici, aucun nouveau chemin d'exécution n'est créé : une
affectation est une instruction, que nous considérons comme atomique. Il
est donc possible de l'inclure dans un bloc atomique pour le
model-checker.

\subsection{Variables globales}

Passons maintenant au cas où la proposition atomique ne dépend que de
variables globales.

Tout comme une variable locale, si une variable globale est modifiée
dans la zone de validité d'une proposition atomique et que cette
proposition atomique dépend de la variable globale, il est nécessaire
d'actualiser la valeur de la proposition atomique et d'effectuer une
transition dans l'automate. Mais une variable globale peut aussi
affecter la valeur d'une proposition atomique lors d'une affectation
hors de la zone de validité de cette proposition : si un pointeur
d'exécution du programme est dans la zone de validité et qu'une variable
globale dont dépend la proposition est modifiée dans un autre thread,
cette modification a un impact sur la valeur de la proposition atomique.

\paragraph{Exemple}
Les listings~\ref{lst:instr_glob_issue1} et \ref{lst:instr_glob_issue2}
illustrent ce problème.

\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
  \begin{lstlisting}[language=C, frame=single, numbers=left,
    caption=Thread 1, label=lst:instr_glob_issue1]
int a = 1;
/* Atomic proposition */
int pred(int a) {
    return a != 0;
}
void* thread1(void* d) {
    a = 0;
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
  \begin{lstlisting}[language=C, frame=single, numbers=left,
    caption=Thread 2, label=lst:instr_glob_issue2]
void* thread2(void* d) {
    int b = *(int *)d;
    int r;
    begin: ;
    a = b;
    r = 10 / a;
    end: ;
}
\end{lstlisting}
\end{minipage}
\end{figure}

On désire s'assurer que la variable \texttt{a} n'est pas nulle dans
la zone de validité allant de \texttt{begin} à \texttt{end} dans
le second thread. L'affectation \texttt{a = b;} est susceptible de
faire évoluer cette propriété, il est donc nécessaire de l'instrumenter,
tout comme dans le cas des variables locales.

L'affectation \texttt{a = 0} dans le premier thread peut aussi avoir
un impact sur la propriété, mais cela dépend de l'ordre d'exécution des
instructions :

\begin{itemize}
\item
  si l'ordre d'exécution est \texttt{a = b; a = 0; r = 10 / a}, alors
  l'affectation \texttt{a = 0;} du second thread doit impacter la
  valeur de la proposition atomique : \texttt{a} est maintenant nulle
  dans la zone de validité.
\item
  si le second thread s'exécute entièrement avant le premier, quand
  \texttt{a = 0;} est exécuté, la proposition atomique n'est pas dans
  sa zone de validité (le pointeur d'exécution du premier thread n'a pas
  encore atteint le label \texttt{begin}). Dans ce cas, la valeur de
  la proposition atomique ne doit pas être modifiée.
\end{itemize}

Il est donc nécessaire d'instrumenter aussi les affectations à des
variables globales hors de la zone de validité d'une proposition.
Cependant, une affectation en dehors d'une zone de validité ne doit pas
non plus systématiquement donner lieu à une actualisation des
propositions atomiques : il ne faut actualiser la valeur de la proposition
atomique que lorsqu'un pointeur d'exécution est dans sa zone de
validité. C'est donc une notion dynamique, qui dépend de l'exécution.

Pour n'actualiser la valeur que lorsque c'est nécessaire,
l'instrumentation prendra la forme d'une condition. Nous ajoutons une
variable globale pour chaque proposition atomique, qui indique si le
programme est dans sa zone de validité. On maintient la valeur de cette
variable à l'entrée et à la sortie de chaque zone de validité. On peut
alors tester la valeur de cette variable pour définir s’il faut
actualiser ou non la proposition atomique.

La valeur de cette nouvelle variable globale doit être actualisée à
l'entrée et à la sortie des zones de validités. L'instrumentation de ces
zones devient donc :

\noindent\begin{minipage}{.47\textwidth}
  \begin{lstlisting}[language=C, frame=single, numbers=left,
    caption=Entrée d'une zone de validité (2), label=lst:instr_in2]
__atomic_begin();
_ltl2ba_active_p = 1;
ltl2ba_atomic_p = fp(..);
_ltl2ba_transition();
__atomic_end();
lbegin: ....;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.47\textwidth}
  \begin{lstlisting}[language=C, frame=single, numbers=left,
    caption=Sortie d'une zone de validité (2), label=lst:instr_out2]
__atomic_begin();
_ltl2ba_active_p = false;
ltl2ba_atomic_p = {v_default};
_ltl2ba_transition();
__atomic_end();
lend: ....;
\end{lstlisting}
\end{minipage}

On remarque, à la seconde ligne des listings \ref{lst:instr_out1} et
\ref{lst:instr_out2}, que la variable \texttt{\_ltl2ba\_active_p} est mise
à jour.

On utilise alors cette information dans l'instrumentation lors de la
modification d'une variable globale, qui prend alors la forme suivante :

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Pour des instructions situées dans la zone de validité de la
  proposition :
\end{enumerate}

\begin{lstlisting}[language=C, frame=single, numbers=left,
  caption=Instrumentation pour une variable globale dans la zone de validité]
__atomic_begin();
g = ....;
ltl2ba_atomic_p = fp(g, ...);
_ltl2ba_transition();
__atomic_end();
\end{lstlisting}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{1}
\item
  Pour des instructions situées hors de la zone de validité de la
  proposition :
\end{enumerate}

\begin{lstlisting}[language=C, frame=single, numbers=left, label=lst:instr_global_out,
  caption=Instrumentation pour une variable globale hors de la zone de validité]
  __atomic_begin();
  g = ....;
  if (_ltl2ba_active_p) {
    ltl2ba_atomic_p = fp(g, ...);
    _ltl2ba_transition();
  }
  __atomic_end();
\end{lstlisting}

On retrouve la même instrumentation que dans le cas des variables locales,
mais la troisième ligne du listing \ref{lst:instr_global_out} utilise la
variable \texttt{\_ltl2ba\_active_p} pour déterminer comment évaluer la
proposition atomique.

\subsection{Mélange de variables globales et locales}

Enfin, plaçons-nous dans le cas où une proposition atomique dépend à la
fois de variables globales et de variables locales.

Un nouveau problème apparaît : lorsqu'une variable globale est modifiée
hors de la zone de validité, il peut être nécessaire de mettre à jour la
proposition atomique à l'aide de sa fonction d'évaluation, comme nous
l'avons vu précédemment. Cette fonction prend en paramètre les variables
locales dont dépend la proposition atomique. Mais ces variables locales
ne sont pas dans le contexte de l'appel ! Celui-ci est réalisé depuis un
autre thread, depuis lequel ces variables locales ne sont pas
accessibles.

\paragraph{Exemple}
Dans le code suivant, on veut vérifier que les variables \texttt{a} et
\texttt{b} sont bien égales durant tout l'intervalle de validité de la
proposition.

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=C, frame=single, numbers=left, caption=Thread 1]
int a = 1;
int pred(int a, int b) {
  return a == b;
}
void* thread1(void* d) {
  a = 0;
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=C, frame=single, numbers=left, caption=Thread 2]
void* thread2(void* d) {
  int b = *(int *)d;
  int r;
  begin: a = b;
  r = 10 / a;
  end: ;
}
\end{lstlisting}
\end{minipage}

Le premier thread serait instrumenté de la manière suivante :

\begin{lstlisting}[language=C, frame=single, numbers=left,
  caption=Thread 2 instrumenté]
void* thread2(void* d) {
  __atomic_begin();
  a = 0;
  if (_ltl2ba_active_p) {
    // Here, b is not in the context
    ltl2ba_atomic_p = pred(a, b);
    _ltl2ba_transition();
  }
  __atomic_end();
}
\end{lstlisting}

On remarque que la variable \texttt{b} n'est pas accessible lorsqu'il
est nécessaire d'appeler la fonction d'évaluation.

Cependant, on sait que lorsque cet appel a lieu, un pointeur d'exécution
du programme est dans la zone de validité de la proposition : toutes les
variables locales dont dépend la proposition sont donc dans la pile. On
peut alors y accéder de manière indirecte, en utilisant des pointeurs
globaux contenant les adresses de ces variables. Nous allons donc
compléter l'instrumentation pour maintenir des adresses de toutes les
variables utilisées comme paramètre d'une proposition atomique.

Pour chaque variable utilisée comme paramètre d'une proposition
atomique, une variable globale supplémentaire est créée. À l'entrée dans
la zone de validité d'une proposition, cette variable globale est
assignée avec l'adresse du paramètre auquel elle correspond. Il est
alors possible d'accéder à la valeur de la variable en déréférençant ce
pointeur global.

\paragraph{Exemple}
On obtient enfin la version finale de l'instrumentation pour l'exemple
précédent.

\begin{lstlisting}[language=C, frame=single, numbers=left,
  caption=Instrumentation finale pour des variables locales et globales]
int a = 1;
int _ltl2ba_active_p = 0;
int *_ltl2ba_ptr_b;
int _ltl2ba_atomic_p = {v_default};
int pred(int a, int b) { return a == b; }

void* thread1(void* d) {
  __atomic_begin();
  a = 0;
  if (_ltl2ba_active_p) {
    ltl2ba_atomic_p = pred(a, *_ltl2ba_ptr_b);
    _ltl2ba_transition();
  }
  __atomic_end();
}
void* thread2(void* d) {
  int b = *(int *)d;
  int r;
  begin: __atomic_begin();
  _ltl2ba_active_p = 1;
  _ltl2ba_ptr_b = &b;
  ltl2ba_atomic_p = pred(a, *_ltl2ba_prt_b);
  _ltl2ba_transition();
  __atomic_end();
  a = b;
  r = 10 / a;
  __atomic_begin();
  _ltl2ba_active_p = 0;
  ltl2ba_atomic_p = {default_val};
  _ltl2ba_transition();
  __atomic_end();
  end: ;
}
\end{lstlisting}

À ce niveau, l'instrumentation est terminée. Le code source obtenu, composé du
système instrumenté et de l'automate de Büchi peut être vérifié.

\section{Vérification à l'aide d'un model-checker}

Nous en sommes enfin à l'étape~3 du processus présenté par la
Figure~\ref{fig:baProduct_func}. Nous avons produit, à partir de la
spécification et du code du système, un nouveau code spécifié par des
assertions.

Un model-checker permet alors de vérifier ce code. Selon les assertions que le
code va violer, il est possible de déterminer si le programme contient une
erreur ou non. Le contre-exemple fourni par le model-checker permet de
retrouver l'erreur dans le programme instrumenté, et donc, en ignorant les
lignes ajoutées par l'instrumentation, dans le système d'origine.

Certains model-checkers arrêtent l'exploration du système dès qu'une assertion
est violée. Un résultat plus faible que le résultat attendu peut alors
être remonté, si une trace violant l'assertion correspondant au résultat plus
faible est explorée avant une trace prouvant le résultat plus fort. Il peut donc
être nécessaire de réaliser plusieurs passes de vérification en désactivant
certaines assertions pour s'assurer d'obtenir le résultat le plus fort.

\section{Implémentation}

Nous avons implémenté cette transformation de source à source dans un outil,
baProduct.

Nous générons les automates de Büchi correspondant aux formules LTL en
utilisant le logiciel LTL2BA\cite{ltl2ba}. LTL2BA implémente
une méthode rapide afin de construire l'automate de Büchi associé à une
formule LTL, en utilisant un co-automate de Büchi alternant très faible
(\emph{very weak alternating co-Büchi automaton}) et un automate de
Büchi généralisé (*generalized Büchi automaton) comme intermédiaires.

L'instrumentation est réalisée à l'aide la bibliothèque
CIL\cite{cil}, en OCaml\cite{ocamlrefman}. CIL permet de parser
du code C et de construire un arbre de syntaxe abstraite plus concis que
celui du C mais d'un niveau plus haut que celui des langages
intermédiaires utilisés dans les procédés de compilation. La
bibliothèque ocamlgraph\cite{ocamlgraph} est utilisée pour réaliser
l'analyse d'accessibilité dans les automates.

Notre implémentation comprend :

\begin{itemize}
\item
  la version modifiée de LTL2BA. Son fonctionnement est identique à
  celui de la version d'origine, seule une option \texttt{-t} a été
  ajoutée afin de choisir le type de la sortie. Cette option peut
  prendre les valeurs \texttt{spin}, \texttt{c} ou
  \texttt{json} pour obtenir un automate en Promela, C et JSON
  respectivement.
\item
  L'utilitaire \texttt{baProduct}. Il s'agit du programme réalisant
  l'instrumentation. Il prend en entrée un fichier C préprocessé et un
  fichier de spécification, et il produit un fichier instrumenté. Cet
  utilitaire a besoin de la version modifiée de LTL2BA pour fonctionner.
\item
  Un script de lancement, \texttt{baProduct.py}. Il préprocesse les
  fichiers en entrée et appelle \texttt{baProduct} avec un ensemble
  d'options classiques.
\end{itemize}

Une utilisation classique de notre implémentation ressemble donc à
l'appel suivant (avec ESBMC\cite{ESBMC} utilisé en backend) :

\begin{lstlisting}
~ ./baProduct.py -i test.c -s test.spec -o test_instr.c
~ esbmc --depth 100 test_instr.c
\end{lstlisting}

Le code de ces outils et une série de tests sont disponibles sur Github, aux
adresses\\
\href{https://github.com/xNephe/baProduct}{https://github.com/xNephe/baProduct}
et
\href{https://github.com/xNephe/ltl2ba}{https://github.com/xNephe/ltl2ba}.
\section{Résultats expérimentaux}

Afin de tester notre approche, nous avons mis en place une suite de tests
permettant d'évaluer les performances de vérification du code instrumenté avec
plusieurs model-checkers. Les tests mettent en jeu des erreurs liées au
non-déterminisme de contrôle (i.e. les différents entrelacements possibles dans
le système). Ils modélisent des versions très simplifiées de systèmes usuels,
parmi lesquels un feu tricolore, un système producteur-consommateur ou un
système d'alimentation.

Nous avons réalisé les tests sur un ordinateur muni de 6~Go de RAM, équipé d'un
processeur Intel Core i7 (4 coeurs cadencés à 3,7GHz), sous Fedora~25 (64 bits).
Nous avons utilisé CBMC\cite{CBMC} version~5.7 et ESBMC\cite{ESBMC} version~4.2.
ESBMC nécessite une borne sur le nombre de changements de contextes, que nous
avons fixé à 3, sauf pour le test \emph{prod\_cons\_simple}, où elle est de 7
(en raison d'un plus grand nombre de threads). En présence de boucles, nous
avons limité l'exploration à trois itérations.

CBMC et ESBMC étant des model-checkers bornés, ils se combinent très bien avec
notre approche, qui exige une exécution finie. Nous avons tenté d'utiliser
d'autres types de model-checkers pour effectuer les tâches de vérification (en
particulier Threader, Divine et Lazy CSeq). Cependant, ces essais n'ont pas été
fructueux. Nous avons rencontré des difficultés techniques lors de
l'installation ou la compilation de ces outils, ainsi que des erreurs de parsing
du code instrumenté. Pour Threader, l'incompatibilité vient de l'approche
choisie : Threader ne considère pas de fonction \texttt{main} dans un programme
et vérifie uniquement les threads alors que notre transformation nécessite qu'un
programme commence et se termine dans la fonction \texttt{main}.

Les tableaux~\ref{tbl:resultats} et~\ref{tbl:performances} présentent les
résultats que nous avons obtenus.

\begin{table}[tbp]
\centering
\caption{Résultats de la vérification d'un benchmark instrumenté par baProduct}
\label{tbl:resultats}
\begin{tabular}{|l|l|l|l|}
\hline
Scénario de test           & CBMC                 & ESBMC            & Résulat attendu \\
\hline
answer\_simple             & ERROR MAYBE          & ERROR MAYBE      & ERROR MAYBE     \\
answer\_simple\_valid      & \textbf{ERROR MAYBE} & VALID MAYBE      & VALID MAYBE     \\
battery\_simple            & ERROR SURE           & ERROR SURE       & ERROR SURE      \\
battery\_var               & ERROR SURE           & \textbf{*}\footnote{Erreur à l'exécution}& ERROR SURE      \\
crossing\_exclusive\_green & VALID MAYBE          & VALID MAYBE      & VALID MAYBE     \\
crossing\_exclusive\_mutex & VALID MAYBE          & VALID MAYBE      & VALID MAYBE     \\
crossing\_GF\_green        & ERROR MAYBE          & ERROR MAYBE      & ERROR MAYBE     \\
crossing\_order            & VALID MAYBE          & VALID MAYBE      & VALID MAYBE     \\
prod\_cons\_mutex          & VALID MAYBE          & VALID MAYBE      & VALID MAYBE     \\
prod\_cons\_simple         & ERROR SURE           & \textbf{VALID SURE} & ERROR SURE      \\
race                       & ERROR MAYBE          & ERROR MAYBE      & ERROR MAYBE     \\
\hline
\end{tabular}
\end{table}

\begin{table}[tbp]
\centering
\caption{Performances pour la vérification d'un benchmark instrumenté par baProduct}
\label{tbl:performances}
\begin{tabular}{|l|c|c|c|c|}
\hline
                           & \multicolumn{2}{c|}{CBMC} & \multicolumn{2}{c|}{ESBMC}\\
Scénario de test           & Temps (s) & Mémoire (MB) & Temps (s) & Mémoire (MB) \\
\hline
answer\_simple             & 0.87      & 42           & 5.57      & 56           \\
answer\_simple\_valid      & 0.81      & 41           & 12.91     & 72           \\
battery\_simple            & 1.07      & 42           & 13.95     & 61           \\
battery\_var               & 666.04    & 954          & N/A       & OOM          \\
crossing\_exclusive\_green & 2.93      & 44           & 32.12     & 119          \\
crossing\_exclusive\_mutex & 1.73      & 44           & 32.20     & 120          \\
crossing\_GF\_green        & 1.99      & 46           & 41.70     & 117          \\
crossing\_order            & 1.02      & 40           & 11.62     & 56           \\
prod\_cons\_mutex          & 10,046.32 & 593          & 229,99    & 28           \\
prod\_cons\_simple         & 1.70      & 52           & 454.00    & 2711         \\
race                       & 1.08      & 41           & 5.65      & 28           \\
\hline
\end{tabular}
\end{table}

Comme on peut le constater dans le tableau~\ref{tbl:resultats}, CBMC et ESBMC
permettent généralement de mener à bien la tâche de vérification et de trouver
un résultat correct. On observe cependant quelques erreurs. CBMC indique une
erreur possible dans un test valide, alors que ESBMC ne détecte pas une erreur
dans un test incorrect. ESBMC échoue aussi sur le test \emph{battery\_var} après
avoir consommé l'ensemble de la mémoire disponible. Ces résultats sont dus à des
erreurs internes aux model-checkers, pour lesquelles nous n'avons pas d'explication.
Le test \emph{battery_var} est l'un de ceux nécessitant la plus grande
profondeur d'exploration et générant le plus d'entrelacement, ce qui explique
le temps nécessaire à CBMC pour conclure, et l'erreur d'exécution de ESBMC.

Les résultats attendus et ceux fournis par les model-checkers sont généralement
incertains (\texttt{MAYBE}). Cela est normal, puisqu’on considère des
propriétés de sûreté ou d'accessibilité sur des programmes finis, pour
lesquelles on ne peut pas conclure de manière certaine. Le fait de savoir que le
programme a terminé son exécution dans ces cas permet de rendre le
verdict définitif.

Pour les mesures de performances, nous ne tenons compte que du temps utilisé par
le model-checker pour vérifier le fichier instrumenté. Le temps pris par
l'instrumentation est négligeable (moins d'une seconde). Si plusieurs passes de
vérification sont nécessaires pour s'assurer qu'une assertion n'en masque pas
une autre, nous considérons la somme des temps d'exécution. Le
tableau~\ref{tbl:performances} permet de constater que CBMC est bien plus
efficace sur ce benchmark que ESBMC. Nous interprétons cet écart de performances
par la manière dont ces deux model-checkers prennent en charge la concurrence.
CBMC construit une unique formule représentant tous les entrelacements, qu'il
délègue ensuite à un SAT solveur, alors que ESBMC explore les entrelacements de
manière explicite. Les erreurs dans nos tests sont principalement basées sur un
entrelacement particulier des threads, ce qui est plus compatible avec
l'approche de CBMC. On peut cependant noter une très bonne performance de ESBMC
sur le test \emph{prod\_cons\_mutex}, sur lequel CBMC est extrêmement lent. Dans
ce cas, ESBMC a probablement eu la chance d'explorer rapidement un entrelacement
permettant de conclure.

\section{Limitations et pistes d'améliorations}

La transformation de source à source et l'outil que nous présentons dans ce
chapitre restent limités. Parmi ces limitations, nous pensons que certaines
pourraient être surmontées relativement facilement par des travaux futurs qui
sortaient du cadre de cette maîtrise. D'autres limitations sont liées au choix
de construire une instrumentation du code plutôt qu'étendre directement un
model-checker. Elles pourraient donc être contournées en changeant d'approche.
Enfin, certaines sont des problèmes plus complexes et difficiles à surmonter.

La principale limitation de notre travail est qu'il est limité à l'analyse de
programmes dont toutes les traces terminent, afin que les appels à la fonction
d'analyse des résultats soient examinés. Cette restriction est inhérente à une
instrumentation, une extension d'un model-checker ne rencontrerait pas ce
problème : l'état final de l'automate peut être examiné une fois l'exploration
du système terminée, qu'il contienne ou non des traces infinies.

Nous n'avons pas abordé la question des accès indirects aux variables (à travers
un pointeur ou un tableau par exemple). Ces derniers pourraient être pris en
charge à l'aide d'une instrumentation plus lourde, se basant sur une analyse
statique des cibles possibles des pointeurs et procédant ensuite par disjonction
de cas.

Notre instrumentation provoque potentiellement des pertes de précision dans la
vérification, en introduisant des chemins dans le programme instrumenté qui
n'étaient pas présent dans le programme initial. Ce phénomène est présent à
l'entrée des zones de validité, où l'instrumentation ne peut être regroupée dans
un bloc atomique avec l'instruction la précédant immédiatement dans une
exécution. Cette perte de précision ne nous a pas posé de problèmes au cours de
nos tests. Une procédure de vérification de notre spécification directement
intégrée dans un model-checker ne rencontrerait probablement pas cette perte de
précision.

Nous n'avons pas cherché à optimiser les performances de notre outil ou à
lutter contre l'explosion combinatoire. En particulier, nous n'utilisons pas de
techniques de réduction ou d'ordre partiels dans notre instrumentation. Celles
utilisées par les model-checkers en backend n'ont pas connaissance de la logique
de l'instrumentation et de la spécification, ce qui peut limiter leur
efficacité. Une extension à notre travail serait de mettre en place des
techniques de réduction tenant compte de la spécification et de l'instrumentation
afin de limiter l'exploration de chemins d'exécution équivalents. Rendre
atomiques les zones du programme sans impact sur les valeurs des propositions
atomiques pourrait être un premier pas. Une autre approche pourrait être de
restreindre l'automate de Büchi composé avec le système afin d'éviter
l'exploration de branches entières de l'arbre des exécutions. La vérification ne
serait cependant plus complète, mais certaines erreurs pourraient être détectées
plus efficacement. Il est déjà possible de restreindre manuellement l'automate
de Büchi dans le code instrumenté.

Nous n'apportons pas de solution au problème de désignation des variables
locales, dans le cas où plusieurs instances d'une même variable lexicale
cohabitent. Intégrer l'approche choisie par Divine\cite{Divine_LTL} pourrait
constituer une solution partielle.

Enfin, notre formalisme de spécification reste très verbeux, ce qui nuit à sa
clarté. Mettre en place une syntaxe plus concise afin de rassembler les
constituants d'une proposition atomique permettrait une lecture plus simple d'une
spécification.
