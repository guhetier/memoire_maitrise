\chapter{Exprimer la spécification par des assertion à l'aide d'une
instrumentation}\label{sec:Theme2}

Nous avons présenté un formalisme de spécification basé sur \ac{LTL} dans le
chapitre~\ref{sec:Theme1}. Notre objectif est maintenant d'établir un outil
permettant de vérifier un programme concurrent en C, spécifié dans ce
formalisme.

Construire un outil de model-checking performant et adapté à notre spécification
dépasse de loin le cadre de cette maîtrise. Nous allons donc nous baser sur les
outils existants. Cependant, la plupart des outils de model-checking pour des
programmes concurrents en C ne supportent pas \ac{LTL}, alors que notre
spécification est basé sur cette logique temporelle. Adapter un model-checker
sera donc une tâche complexe.

Cependant, presque tous les model-checkers logiciels supportent les assertions.
Nous avons par conséquent mis en place une transformation source à source du
système. A partir des sources d'un système et de sa spécification, elle produit
un programme instrumenté, contenant des assertions, tel que la validité de ce
programme instrumenté par rapport aux assertions corresponde à celle du
programme initial par rapport à sa spécification.

Construire une transformation de source à source présente de plus un certain
nombre d'avantages. Elle est en grande partie indépendante du model-checker
utilisé pour effectuer la vérification, ce qui permet d'obtenir un outil
compatible avec plusieurs backend. On peut ainsi les comparer et sélectionner le
plus adapté pour un problème spécifique. Utiliser une instrumentation du code
simplifie aussi les tâches d'implémentation, en nous évitant de composer avec le
code d'un système préexistant et la représentation interne d'un model-checker.
Cependant, ce choix a aussi des inconvénients. En particulier, une
instrumentation représente une perte de précision et de performance par rapport
à un traitement direct : des variables et des instructions sont ajoutées dans le
système et vont être traitée comme n'importe quelle instruction par les
model-checkers en backend, alors qu'elles suivent une logique qui pourrait être
utilisée pour les traiter plus efficacement.

La transformation de source à source que nous proposons s'inspire fortement de
celle mise en place dans \cite{morse_ltl}. Elle se base sur la composition d'un
automate de Büchi représentant la négation de la propriété \ac{LTL} à prouver
avec le programme à valider. Un model-checker doit ensuite être utilisé pour
explorer le produit du système avec l'automate. La composition du système avec
un automate de Büchi est une technique classique pour le model-checking de
propriétés LTL\cite{25_years_of_model_checking}. La particularité de notre
approche est de construire ce produit au niveau du code source du système, et
non pas au niveau de la représentation interne d'un model-checker (où le système
et l'automate sont vus comme des systèmes de transitions).

La figure~\ref{fig:baProduct_func} présente le fonctionnement de l'outil que
nous avons conçu, nommé \emph{baProduct}. Trois phases principales
apparaissent :

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
  \item Construire un automate de Büchi à partir de la spécification, et le
    convertir en code C ;
  \item Instrumenter le code source du système en entrée pour construire le
    produit entre le système et l'automate de Büchi ;
  \item Vérifier le code produit à l'aide d'un model-checker et analyser les
    résultats.
\end{enumerate}

\begin{figure}
\begin{center}
  \includegraphics[width=\textwidth]{baProduct_organization.png}
\end{center}
\caption{Schéma fonctionnel de baProduct}
\label{fig:baProduct_func}
\end{figure}

Dans la suite de ce chapitre, nous allons détailler ces trois étapes. Nous
présenterons ensuite notre implémentation, puis une analyse de ses performances
sur une série d'exemples avec différents model-checkers utilisés pour les tâches
de vérification.

\section{Construction de l'automate de Büchi}

Nous reprenons une technique classique de vérification des propriétés \ac{LTL},
utilisée en particulier par SPIN\cite{SPIN} : construire un automate de Büchi
représentant la négation de la propriété \ac{LTL} et le composer avec le
système. Une exécution acceptée par le système résultant est un contre-exemple à
la spécification.

Mais alors que de manière générale, le programme à vérifier est représenté par
un système de transitions avant d'être composé avec l'automate de Büchi, nous
allons ici représenter l'automate de Büchi en C avant de le composer avec le
programme.

Des algorithmes efficaces et éprouvés permettent de construire l'automate de
Büchi représentant une formule \ac{LTL}\cite{ltl2ba}. Nous allons donc nous
concentrer sur l'implémentation d'un automate en C.

Cependant, vouloir vérifier des propriétés \ac{LTL} à l'aide d'une
instrumentation à une conséquence : il n'est possible de vérifier que des traces
finies. En effet, les model-checkers utilisent la présence de cycles dans les
traces infinies pour les traiter : une fois le cycle atteint, le comportement du
programme est totalement connu et il est possible de conclure si oui ou non, il
vérifie une spécification. Mais du point de vue d'une instrumentation, il n'est
pas possible de détecter un cycle, et il n'est donc pas possible de déterminer à
quel moment prononcer une conclusion pour une trace infinie : l'ensemble des
comportement du programme n'a peut être pas encore eu lieu, un nouveau
comportement pourrait modifier le verdict. Dans le cas d'une trace finie, par
contre, il suffit de conclure à la fin de la trace. Pour une instrumentation,
cela revient à placer une fonction de ``conclusion'' juste avant les points de
sortie du programme.

Nous allons donc pour la suite nous restreindre à des traces finies. Puisque
\ac{LTL} est définie sur des traces infinies, nous allons voir tout d'abord
comment interpréter une formule \ac{LTL} dans le cas d'une trace finie, avant
d'expliquer notre construction en C de l'automate de Büchi associé.

\subsection{Traces finies et logique à 4 valeurs de vérité}

Les propriétés \ac{LTL} ne sont pas définies sur les traces finies. Plusieurs
variantes de \ac{LTL} existent pour répondre à ce problème (LTL3, FLTL, RV-LTL,
infinite extension\ldots{}), aucune ne faisant consensus.

Nous avons choisi l'approche du \emph{stuttering} : l'état final de la
trace finie est répété à l'infini afin d'étendre la trace de manière
infinie. Cette approche correspond bien avec un programme qui, lorsqu'il
se termine, n'a pas de raison de voir son état évoluer. Elle a de plus
l'avantage de ne pas modifier les opérateurs \ac{LTL}, ce qui nous permet
d'utiliser les techniques de vérification pour \ac{LTL} sans modifications.
Une trace finie est un modèle d'une propriété \ac{LTL} dans la sémantique
avec \emph{stuttering} si et seulement si son extension infinie est un
modèle.

\paragraph{Exemple}
Soient \(p\) et \(q\) deux états d'un système. Soit la trace finie \(t =
pqpqpqp\). Alors, l'extension infinie de \(t\) est la trace \(t' =
pqpqpppppp\dots\).

\(t'\) ne vérifie pas \(G p\) mais vérifie \(F(G p)\), il en va donc de même
pour la trace finie \(t\).

Il faut cependant noter que les différentes variantes de \ac{LTL} pour des
traces finies diffèrent principalement par la prise en charge de
l'opérateur \emph{next}. Dans le cadre du software model-checking, le
sens donné à celui-ci est très variable et il est généralement
déconseillé de l'utiliser.

Une trace finie ne correspond pas toujours à une exécution réelle du système.
Il peut s'agir seulement d'un préfixe d'une exécution plus longue, par exemple,
le nombre d'itération d'une boucle à pu être limité. La prolongation de la
sémantique d'extension infinie ne reflète donc pas forcément le comportement
réel du système.

\paragraph{Exemple}
La trace \(t = pqpqpqp\) de l'exemple précédent est peut être le préfixe d'une
trace \(t'' = pqpqpq\dots pq\dots\), qui aurait été interrompue. Cette trace ne
vérifie pas la propriété \(F (G p)\), contrairement à \(t\).

Pour tenir compte de ce comportement, il est possible de raffiner d'avantage les
résultats en faisant la distinction entre deux types de traces finies :

\begin{itemize}
\item
  le préfixe fini est suffisant pour déterminer si la trace est un
  modèle de la formule ou non, quelque soit l'extension
  (\emph{stuttering} ou autre)
\item
  le préfixe fini n'est pas suffisant, le résultat dépend de l'extension
\end{itemize}

\paragraph{Exemple}
Le préfixe fini \(t = pqpqpqp\) est suffisant pour établir que \(t\) ne vérifie
pas \(G p\), quelque soit l'extension. Pour \(F (G p)\), cependant, nous avons
vu que le résultat dépends de l'extension choisie.

Nous avons de plus utilisé une logique à 4 valeurs de vérités, comme
décrite dans \cite{morse_ltl}. Nous pourrons ainsi, selon la catégorie d'une
trace, affecter des valeurs de vérités différentes.

Étant donné une propriété et un automate de Büchi associé à cette propriété, on
définie les quatre valeurs de vérité par :

\begin{itemize}
\item
  \textbf{True} : utilisée lorsque, étant donnée une trace finie \texttt{t},
  toutes les traces ayant \texttt{t} pour préfixe sont acceptées par
  l'automate.
\item
  \textbf{Maybe true} : utilisée lorsque, étant donnée une trace finie
  \texttt{t}, l'extension infinie de \texttt{t} en répétant son
  dernier état est acceptée par l'automate.
\item
  \textbf{Maybe false} : utilisée lorsque étant donnée une trace finie
  \texttt{t}, l'extension infinie de \texttt{t} en répétant son
  dernier état est rejeté par l'automate mais que au moins une trace
  ayant \texttt{t} pour préfixe est acceptée.
\item
  \textbf{False} : utilisée lorsque, étant donnée une trace finie \texttt{t},
  toutes les traces ayant \texttt{t} pour préfixe sont rejetées par
  l'automate.
\end{itemize}

Les deux valeurs \emph{True} et \emph{False} permettent de conclure de manière
certaine, lorsque le résultat ne dépend pas de l'extension. Si le résultat
dépend de l'extension, les valeurs \emph{Maybe true} et \emph{Maybe false}
permette d'indiquer que le résultat est relatif à la sémantique d'extension
infinie.

Dans les cas d'une conclusion \emph{Maybe true} ou \emph{Maybe false},
la connaissance supplémentaire du fait que le programme ait terminé ou
non son exécution (i.e on a vérifié l'exécution complète ou la
profondeur d'exploration a été bornée) peut permettre de préciser le
résultat.

\subsection{Implémentation de l'automate}

La génération d'un automate de Büchi en C est la première étape réalisée par
notre outil (étape 1 dans la Figure~\ref{fig:baProduct_func}). Cet automate doit
représenter la négation de la propriété \ac{LTL} présente dans la spécification,
et permettre de déduire un résultat dans la logique à 4 valeurs de vérité.
L'implémentation de cet automate reprend l'approche décrite dans
\cite{morse_ltl}.

Les états de l'automate sont indicés selon un ordre arbitraire. On réfère à un
état dans le code par son indice. La partie principale de l'implémentation de
l'automate est sa fonction de transition. Elle est implémenté à travers une
fonction C, qui permet de déterminer l'évolution de l'état de l'automate selon
l'état courant et les valeurs des propositions atomiques.

Nous utilisons les variables et fonctions suivantes pour construire l'automate :

\begin{itemize}
\item
  une variable globale, \texttt{ltl2ba\_state\_var}, contient l'état
  courant de l'automate sous la forme d'un entier (les états sont
  numérotés arbitrairement)
\item
  des variables globales, \texttt{ltl2ba\_atomic\_{name}} (où name est
  l'identifiant d'une proposition atomique), contiennent la valeur
  courante de chaque proposition atomique. Ces valeurs sont maintenues à
  jour pendant le déroulement du programme. Elles sont mises à jour par
  des instructions ajoutées dans le code du programme que nous
  détaillerons dans la partie sur l'instrumentation.
\item
  une fonction \texttt{\_ltl2ba\_transition} représente la fonction de
  transition de l'automate et fait évoluer l'état stocké dans
  \texttt{ltl2ba\_state\_var}. Étant donné l'état courant de
  l'automate, elle choisit de manière non-déterministe une transition
  valide partant de cet état et met à jour l'état courant. Si aucune
  transition n'est valable, le mot est rejeté (et l'exploration courante
  est stoppée). Si l'état courant est un état puits acceptant, le mot
  est accepté et une erreur est immédiatement remontée (on rappelle que
  l'automate représente la négation de la propriété à vérifier, une
  trace acceptée par l'automate est donc un contre-exemple à la
  propriété).

  Cette fonction permet de d'explorer l'automate de manière
  non-déterministe. Une valeur non-déterministe est produite l'aide de
  la fonction intrinsèque au model-checker, \texttt{nondet\_int()}. La
  transition à emprunter est désignée à l'aide de cette valeur. Le
  model-checker va alors explorer l'ensemble des évolutions possibles de
  l'automate. Les évolutions invalides sont immédiatement interrompues à
  l'aide d'assomptions.
\item
  une fonction \texttt{\_ltl2ba\_result} permet de déterminer le
  résultat d'une exploration. Elle est appelée après la dernière
  instruction du \texttt{main}. Elle se base sur l'état courant de
  l'automate et la valeur des propositions atomiques pour déterminer la
  valeur de vérité associée à cette exécution. Si une erreur est
  possible, elle est remontée au model-checker à l'aide d'une assertion.
  Les valeurs de vérités sont déterminées en utilisant des données
  pré-calculées par une analyse d'accessibilité dans l'automate de Büchi
  \cite{morse_ltl}.
\end{itemize}

Notre implémentation de l'automate de Büchi en C diffère de celle de
\cite{morse_ltl} par un point d'importance : dans \cite{morse_ltl}, l'automate
est implémenté dans un thread supplémentaire, utilisé comme un thread
observateur. La fonction de transition de l'automate est placée dans une boucle,
synchronisée avec le reste du code à l'aide d'une commande interne du
model-checker. Cette commande à été implémentée pour l'occasion. Dans notre cas,
la fonction de transition est représentée par une fonction dans le code, appelée
quand nécessaire par l'instrumentation. Cela nous permet de ne pas se baser sur
une commande interne pour synchroniser l'automate avec le code et ainsi, de
supporter plus facilement différents model-checkers en back-end.

\paragraph{Exemple}
L'automate pour la propriété LTL \(G p \implies F q\) est implémenté par
le code du listing~\ref{lst:C_automaton}.

\begin{lstlisting}[language=C, frame=single, label=lst:C_automaton,
    caption=Code de l'automate représentant \(G p \implies F q\)]
_Bool _ltl2ba_atomic_p = 0;
_Bool _ltl2ba_atomic_q = 0;
int _ltl2ba_state_var = 0;
void _ltl2ba_transition() {
  int choice = nondet_uint();
  switch (_ltl2ba_state_var) {
  case 0:
    if (choice == 0) {
      assume(!_ltl2ba_atomic_p);
      _ltl2ba_state_var = 0;
    } else if (choice == 1) {
      assume(1);
      _ltl2ba_state_var = 1;
    } else if (choice == 2) {
      assume(_ltl2ba_atomic_q);
      _ltl2ba_state_var = 0;
    } else {
      assume(0);
    }
    break;
  case 1:
    if (choice == 0) {
      assume(1);
      _ltl2ba_state_var = 1;
    } else if (choice == 1) {
      assume(_ltl2ba_atomic_q);
      _ltl2ba_state_var = 0;
    } else {
      assume(0);
    }
    break;
  }
}
_Bool _ltl2ba_surely_accept[2] = {0, 0};
_Bool _ltl2ba_surely_reject[2] = {0, 0};
_Bool _ltl2ba_stutter_accept[8] = {1,0, 0,0, 1,1, 1,1,};
unsigned int _ltl2ba_sym_to_id() {
  unsigned int id = 0;
  id |= (_ltl2ba_atomic_p << 0);
  id |= (_ltl2ba_atomic_q << 1);
  return id;
};
void _ltl2ba_result() {
  _Bool reject_sure = _ltl2ba_surely_reject[_ltl2ba_state_var];
  assume(!reject_sure);
  _Bool accept_sure = _ltl2ba_surely_accept[_ltl2ba_state_var];
  assert(!accept_sure, "ERROR SURE");
  unsigned int id = _ltl2ba_sym_to_id();
  _Bool accept_stutter =
    _ltl2ba_stutter_accept[id * 2 + _ltl2ba_state_var];
  assert(!accept_stutter, "ERROR MAYBE");
  assert(accept_stutter, "VALID MAYBE");
}
\end{lstlisting}

Cet exemple permet de remarquer que le seul moyen de faire remonter un résultat
est à travers une le déclenchement d'une assertion. La violation d'une assertion
met fin à une trace, il est donc important d'ordonner les assertions de manière
à ce que le résultat le plus fort soit le premier à être reporté pour ne pas
qu'il soit masqué. De plus, certain model-checker arrêtent d'explorer le modèle
dès qu'une erreur est reportée. Dans ce cas, il peut être nécessaire de réaliser
plusieurs vérification successive en désactivant les assertions les plus
faibles, pour ne pas qu'un résultat faible masque un résultat plus fort présent
dans une trace future.

\section{Instrumentation du code}

Une fois l'automate implémenté, la seconde étape du processus est de construire
le produit entre le système et l'automate. Cela est réalisé par une
instrumentation du code, afin de maintenir à jour la valeur des propositions
atomiques et d'appeler la fonction de transition de l'automate.

Afin de minimiser l'instrumentation, la valeur d'une propositions atomique est
mise à jour uniquement lorsque un des paramètres dont elle dépend est modifiée
(valeur d'une variable, entrée ou sortie de la zone de validité). La fonction de
transition de l'automate est appelée uniquement à ces occasions. L'opérateur
\ac{LTL} \emph{Next} a alors pour signification ``lors du prochain appel à la
fonction de transition'', c'est à dire la prochaine fois qu'une proposition
atomique est susceptible d'être modifiée.

Différents emplacements du code vont nécessiter une instrumentation, qui va
aussi dépendre du type de paramètre des propositions atomiques. Nous allons
expliquer l'instrumentation nécessaire dans ces différents cas.

\subsection{Frontière des zones de validité}

Les premiers points nécessitant une instrumentation sont les frontières
des zones de validité des propositions atomiques. Lorsqu'un pointeur
d'instruction atteint l'instruction portant le label d'entrée
(respectivement de sortie) d'une zone de validité, la proposition
atomique doit prendre la valeur calculée par sa fonction d'évaluation
(respectivement sa valeur par défaut).

Les listings~\ref{lst:instr_in1} et \ref{lst:instr_out1} présentent
l'instrumentation correspondant à l'entrée et à la sortie des zones de
validités. Ici, la proposition atomique \texttt{p} débute au label
\texttt{lbegin} et se termine au label \texttt{lend}.

\noindent\begin{minipage}{.45\textwidth}
  \begin{lstlisting}[language=C, frame=single, caption=Entrée de zone de
    validité (1),
    label=lst:instr_in1]
__atomic_begin();
ltl2ba_atomic_p = fp(..);
_ltl2ba_transition();
__atomic_end();
lbegin: ....;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
  \begin{lstlisting}[language=C, frame=single, caption=Sortie de zone de
    validité (1),
    label=lst:instr_out1]
__atomic_begin();
ltl2ba_atomic_p = {v_default};
_ltl2ba_transition();
__atomic_end();
lend: ....;
\end{lstlisting}
\end{minipage}

Toutes les instructions sont regroupées dans un bloc atomique (ouvert
par l'instruction \texttt{\_\_atomic\_begin()} et fermé par
l'instruction \texttt{atomic\_end()}) afin de ne pas générer
d'entrelacements supplémentaires dans le code et créer des chemins
d'exécutions pouvant mener à une conclusion erronée : toutes les
instructions de l'instrumentation doivent être réalisées de manière
atomiques (sans changement de contexte possible) pour garantir un état
cohérent de l'automate. Si plusieurs entrées et sorties de zone ont
lieux au même label, les instructions d'instrumentations sont toutes
réunies dans le même bloc atomique. La fonction de transition n'est
appelée qu'une seule fois, après l'actualisation de toutes les
propositions atomiques.

Cependant, cette instrumentation des frontières des zones de validité
provoque tout de même une perte de précision. L'entrée dans une zone de
validité correspond à l'instant où le pointeur d'exécution pointe sur
l'instruction portant le label d'entrée, i.e le moment ou cette
instruction est susceptible d'être exécutée. Le pointeur d'exécution est
mis à jour immédiatement après l'exécution de l'instruction précédent
l'entrée dans la zone, avant tout changement de contexte. Par
conséquent, l'instrumentation devrait avoir lieu immédiatement après
cette instruction, sans permettre un changement de contexte, mais ce
n'est pas le cas dans notre instrumentation.

Illustrons cela sur un exemple.

\begin{lstlisting}[language=C]
instr1;
begin: instr2;
end: instr3;
\end{lstlisting}

Dans ce fragment de code, dès que l'instruction \texttt{instr1} est
exécutée, le pointeur d'exécution pointe sur l'instruction
\texttt{instr2}. On est donc immédiatement dans la zone de validité
délimitée par les labels \texttt{begin} et \texttt{end}, et il
n'est pas possible d'effectuer un changement de contexte après
\texttt{instr1} mais avant d'entrer dans la zone de validité.

Cependant, après instrumentation, on obtient :

\begin{lstlisting}[language=C]
instr1;
{intrumentation;}
begin: instr2;
{instrumentation;}
end: instr3;
\end{lstlisting}

L'entrée dans la zone de validité n'est réalisée qu'une fois que
l'instrumentation a été exécutée et que la valeur des propositions
atomiques a donc été recalculée. Il est donc maintenant possible de
réaliser un changement de contexte après \texttt{instr1}, mais avant
d'entrer dans la zone de validité : un nouveau chemin d'exécution a été
créé.

Pour éviter cette perte de précision, il serait nécessaire de rendre
atomique l'instruction \texttt{instr1} et le code d'instrumentation.
Ceci est extrêmement compliqué dans le cadre d'une instrumentation du
code. En effet, l'instruction qui précède un label n'est pas facilement
identifiable et peut varie selon l'exécution et selon les branchements
du programme. De plus, sans dépliage du code, une même instruction peut
précéder l'entrée ou la sortie d'une zone certaines fois mais pas
systématiquement (instruction en fin de boucle ou de fonction). Dans le
cadre d'une instrumentation du code, nous n'avons aucune solution face à
cette perte de précision. Une implémentation intégrée à un model-checker
serait nécessaire.

On peut cependant noter que les assertions utilisées de manière
classique permettent elles aussi ce changement de contexte immédiatement
avant elles, ce qui n'a généralement pas de conséquences.

\subsection{Variables locales}

Passons à la seconde raison pouvant amener à modifier la valeur d'une
proposition atomique. Il s'agit de la modification d'une variable dont
dépend la proposition atomique, dans sa zone de validité (en dehors de
la zone de validité, la proposition atomique s'évalue toujours à sa
valeur par défaut, la modification d'une variable n'a donc pas
d'impact). Nous allons tout d'abord nous concentrer uniquement sur le
cas des variables locales à une fonction.

Si une variable locale est modifiée dans la zone de validité d'une
proposition atomique et que la valeur de la proposition atomique dépend
de la variable, il est toujours nécessaire d'instrumenter l'affectation.
Instrumenter ces appels est aussi suffisant (car nous ne considérons pas
les accès indirects aux variables). La variable étant locale, elle ne
peut s'échapper hors de son contexte : elle ne peut donc pas être
modifiée par une instruction hors de la zone de validité alors qu'un
pointeur d'instruction est dans la zone de validité.

On peut alors ajouter une instrumentation autour de l'affectation. Après
la modification de la variable, les propositions atomiques qui en
dépendent sont évaluées à nouveau. On tente ensuite d'effectuer une
transition dans l'automate de Büchi.

\begin{lstlisting}[language=C, frame=single, caption=Instrumentation pour une
  variable locale]
__atomic_begin();
v = ....;
ltl2ba_atomic_p = fp(v, ...);
_ltl2ba_transition();
__atomic_end();
\end{lstlisting}

L'affectation de la variable à sa nouvelle valeur et l'instrumentation
sont placés dans un même bloc atomique, afin de la modification de
l'état soit répercutée sans changement de contexte possible.

Contrairement à l'instrumentation à l'entrée et la sortie des zones de
validité, ici, aucun nouveau chemin d'exécution n'est créé : une
affectation est un statement, que nous considérons comme atomique. Il
est donc possible de l'inclure dans un bloc atomique pour le
model-checker.

\subsection{Variables globales}

Passons maintenant au cas où la proposition atomique ne dépend que de
variables globales.

Tout comme une variable locale, si une variable globale est modifiée
dans la zone de validité d'une proposition atomique et que cette
proposition atomique dépend de la variable globale, il est nécessaire
d'actualiser la valeur de la proposition atomique et d'effectuer une
transition dans l'automate. Mais une variable globale peut aussi
affecter la valeur d'une proposition atomique lors d'une affectation
hors de la zone de validité de cette proposition : si un pointeur
d'exécution du programme est dans la zone de validité et qu'une variable
globale dont dépend la proposition est modifiée dans un autre thread,
cette modification a un impact sur la valeur de la proposition atomique.

\paragraph{Exemple}
Les listings~\ref{lst:instr_glob_issue1} et \ref{lst:instr_glob_issue2}
illustrent ce problème.

\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=C, frame=single, caption=Thread 1,
  label=lst:instr_glob_issue1]
int a = 1;
int pred(int a) {
    return a != 0;
}

void* thread1(void* d) {
    a = 0;
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=C, frame=single, caption=Thread 2,
  label=lst:instr_glob_issue2]
void* thread2(void* d) {
    int b = *(int *)d;
    int r;
    begin: ;
    a = b;
    r = 10 / a;
    end: ;
}
\end{lstlisting}
\end{minipage}
\end{figure}

On désire s'assurer que la variable \texttt{a} n'est pas nulle dans
la zone de validité allant de \texttt{begin} à \texttt{end} dans
le second thread. L'affectation \texttt{a = b;} est susceptible de
faire évoluer cette propriété, il est donc nécessaire de l'instrumenter,
tout comme dans le cas des variables locales.

L'affectation \texttt{a = 0} dans le premier thread peut aussi avoir
un impact sur la propriété, mais cela dépend de l'ordre d'exécution des
instructions :

\begin{itemize}
\item
  si l'ordre d'exécution est \texttt{a = b; a = 0; r = 10 / a}, alors
  l'affectation \texttt{a = 0;} du second thread doit impacter la
  valeur de la proposition atomique : \texttt{a} est maintenant nulle
  dans la zone de validité.
\item
  si le second thread s'exécute entièrement avant le premier, quand
  \texttt{a = 0;} est exécuté, la proposition atomique n'est pas dans
  sa zone de validité (le pointeur d'exécution du premier thread n'a pas
  encore atteint le label \texttt{begin}). Dans ce cas, la valeur de
  la proposition atomique ne doit pas être modifiée.
\end{itemize}

Il est donc nécessaire d'instrumenter aussi les affectation à des
variables globales hors de la zone de validité d'une proposition.
Cependant, une affectation en dehors d'une zone de validité ne doit pas
non plus systématiquement donner lieux à une actualisation des
proposition atomique : il ne faut actualiser la valeur de la proposition
atomique que lorsqu'un pointeur d'exécution est dans sa zone de
validité. C'est donc une notion dynamique, qui dépend de l'exécution.

Pour n'actualiser la valeur que lorsque c'est nécessaire,
l'instrumentation prendra la forme d'une condition. Nous ajoutons une
variable globale pour chaque proposition atomique, qui indique si le
programme est dans sa zone de validité. On maintient la valeur de cette
variable à l'entrée et à la sortie de chaque zone de validité. On peut
alors tester la valeur de cette variable pour définir si il faut
actualiser ou non la proposition atomique.

La valeur de cette nouvelle variable globale doit être actualisée
l'entrée et à la sortie des zones de validités. L'instrumentation de ces
zones devient donc :

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=C, frame=single, caption=Entrée de zone de validité (2),
  label=lst:instr_in2]
__atomic_begin();
_ltl2ba_active_p = 1;
ltl2ba_atomic_p = fp(..);
_ltl2ba_transition();
__atomic_end();
lbegin: ....;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=C, frame=single, caption=Sortie de zone de validité (2),
  label=lst:instr_out2]
__atomic_begin();
_ltl2ba_active_p = false;
ltl2ba_atomic_p = {v_default};
_ltl2ba_transition();
__atomic_end();
lend: ....;
\end{lstlisting}
\end{minipage}

L'instrumentation lors de la modification d'une variable globale prend
alors la forme suivante :

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Pour des instructions situées dans la zone de validité de la
  proposition :
\end{enumerate}

\begin{lstlisting}[language=C, frame=single, caption=Instrumentation pour une
  variable globale dans la zone de validité]
__atomic_begin();
g = ....;
ltl2ba_atomic_p = fp(g, ...);
_ltl2ba_transition();
__atomic_end();
\end{lstlisting}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{1}
\item
  Pour des instructions situées hors de la zone de validité de la
  proposition :
\end{enumerate}

\begin{lstlisting}[language=C, frame=single, caption=Instrumentation pour une
  variable globale hors de la zone de validité]
__atomic_begin();
g = ....;
if (_ltl2ba_active_p) {
    ltl2ba_atomic_p = fp(g, ...);
    _ltl2ba_transition();
}
__atomic_end();
\end{lstlisting}

\subsection{Mélange de variables globales et locales}

Enfin, plaçons nous dans le cas où une proposition atomique dépend à la
fois de variables globales et de variables locales.

Un nouveau problème apparaît : lorsqu'une variable globale est modifiée
hors de la zone de validité, il peut être nécessaire de mettre à jour la
proposition atomique à l'aide de sa fonction d'évaluation, comme nous
l'avons vu précédemment. Cette fonction prend en paramètre les variables
locales dont dépend la proposition atomique. Mais ces variables locales
ne sont pas dans le contexte de l'appel ! Celui-ci est réalisé depuis un
autre thread, depuis lequel ces variables locales ne sont pas
accessibles.

\paragraph{Exemple}
Dans le code suivant, on veut vérifier que les variables \texttt{a} et
\texttt{b} sont bien égale durant tout l'intervalle de validité de la
proposition.

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=C, frame=single, caption=Thread 1]
int a = 1;
int pred(int a, int b) {
  return a == b;
}
void* thread1(void* d) {
  a = 0;
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=C, frame=single, caption=Thread 2]
void* thread2(void* d) {
  int b = *(int *)d;
  int r;
  begin: a = b;
  r = 10 / a;
  end: ;
}
\end{lstlisting}
\end{minipage}

Le premier thread serait instrumenté de la manière suivante :

\begin{lstlisting}[language=C, frame=single, caption=Thread 2 instrumenté]
void* thread2(void* d) {
  __atomic_begin();
  a = 0;
  if (_ltl2ba_active_p) {
    // Here, b is not in the context
    ltl2ba_atomic_p = pred(a, b);
    _ltl2ba_transition();
  }
  __atomic_end();
}
\end{lstlisting}

On remarque que la variable \texttt{b} n'est pas accessible lorsqu'il
est nécessaire d'appeler la fonction d'évaluation.

Cependant, on sait que lorsque cet appel a lieu, un pointeur d'exécution
du programme est dans la zone de validité de la proposition : toutes les
variables locales dont dépend la proposition sont donc dans la pile. On
peut alors y accéder de manière indirecte, en utilisant des pointeurs
globaux contenant les adresses de ces variables. Nous allons donc
compléter l'instrumentation pour maintenir des adresses de toutes les
variables utilisées comme paramètre d'une proposition atomique.

Pour chaque variable utilisée comme paramètre d'une proposition
atomique, une variable globale supplémentaire est créée. A l'entrée dans
la zone de validité d'une proposition, cette variable globale est
assignée avec l'adresse du paramètre auquel elle correspond. Il est
alors possible d'accéder à la valeur de la variable en déréférençant ce
pointeur global.

\paragraph{Exemple}
On obtient enfin la version finale de l'instrumentation pour l'exemple
précédent.

\begin{lstlisting}[language=C, frame=single, caption=Instrumentation finale pour
  des variables locales et globales]
int a = 1;
int _ltl2ba_active_p = 0;
int *_ltl2ba_ptr_b;
int _ltl2ba_atomic_p = {v_default};
int pred(int a, int b) { return a == b; }

void* thread1(void* d) {
  __atomic_begin();
  a = 0;
  if (_ltl2ba_active_p) {
    ltl2ba_atomic_p = pred(a, *_ltl2ba_ptr_b);
    _ltl2ba_transition();
  }
  __atomic_end();
}
void* thread2(void* d) {
  int b = *(int *)d;
  int r;
  begin: __atomic_begin();
  _ltl2ba_active_p = 1;
  _ltl2ba_ptr_b = &b;
  ltl2ba_atomic_p = pred(a, *_ltl2ba_prt_b);
  _ltl2ba_transition();
  __atomic_end();
  a = b;
  r = 10 / a;
  __atomic_begin();
  _ltl2ba_active_p = 0;
  ltl2ba_atomic_p = {default_val};
  _ltl2ba_transition();
  __atomic_end();
  end: ;
}
\end{lstlisting}

\section{Implémentation}

Nous avons implémenté cette transformation dans un outil, BaProduct.

Nous générons les automates de Büchi correspondant aux formules LTL en
utilisant le logiciel LTL2BA\cite{ltl2ba}. LTL2BA implémente
une méthode rapide afin de construire l'automate de Büchi associé à une
formule LTL, en utilisant un co-automate de Büchi alternant très faible
(\emph{very weak alternating co-Büchi automaton}) et un automate de
Büchi généralisé (*generalised Büchi automaton) comme intermédiaires.

L'instrumentation est réalisée en utilisant la bibliothèque
CIL\cite{cil}, en OCaml\cite{ocamlrefman}. CIL permet de parser
du code C et de construire un arbre de syntaxe abstraite plus concis que
celui du C mais d'un niveau plus haut que celui des langages
intermédiaires utilisés dans les procédés de compilation. La
bibliothèque ocamlgraph\cite{ocamlgraph} est utilisée pour réaliser
l'analyse d'accessibilité dans les automates.

Notre implémentation comprend :

\begin{itemize}
\item
  la version modifiée de LTL2BA. Son fonctionnement est identique à
  celui de la version d'origine, seule une option \texttt{-t} a été
  ajoutée afin de choisir le type de la sortie. Cette option peut
  prendre les valeurs \texttt{spin}, \texttt{c} ou
  \texttt{json} pour obtenir un automate en Promela, C et JSON
  respectivement.
\item
  L'utilitaire \texttt{baProduct}. Il s'agit du programme réalisant
  l'instrumentation. Il prends en entré un fichier C préprocessé et un
  fichier de spécification, et il produit un fichier instrumenté. Cet
  utilitaire a besoin de la version modifiée de LTL2BA pour fonctionner.
\item
  Un script de lancement, \texttt{baProduct.py}. Il préprocesse les
  fichiers en entrée et appelle \texttt{baProduct} avec un ensemble
  d'options classiques.
\end{itemize}

Une utilisation classique de notre implémentation ressemble donc à
l'appel suivant :

\begin{lstlisting}
~ ./baProduct.py -i test.c -s test.spec
~ esbmc --depth 100 test_instr.c
\end{lstlisting}

Le code de ces outils et une série de tests sont disponible à {[}TODO:
mettre sur github, ajouter adresse{]}
